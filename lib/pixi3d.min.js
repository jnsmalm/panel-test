var PIXI3D=function(A,p,Se,Wt,me,U,Xt,R,je,ce,ct){"use strict";function Jt(r){if(r&&r.__esModule)return r;var e=Object.create(null);return r&&Object.keys(r).forEach(function(t){if(t!=="default"){var n=Object.getOwnPropertyDescriptor(r,t);Object.defineProperty(e,t,n.get?n:{enumerable:!0,get:function(){return r[t]}})}}),e.default=r,Object.freeze(e)}var F=Jt(p),L;(r=>{function e(t,n){return t[n]}r.get=e})(L||(L={}));var ae=(r=>(r[r.buffer=0]="buffer",r[r.json=1]="json",r[r.text=2]="text",r))(ae||{});class dt{setLoaderResourceExtensionType(e,t){let n=Se.LoaderResource.XHR_RESPONSE_TYPE.TEXT;t===ae.buffer?n=Se.LoaderResource.XHR_RESPONSE_TYPE.BUFFER:t===ae.json&&(n=Se.LoaderResource.XHR_RESPONSE_TYPE.JSON),Se.LoaderResource.setExtensionXhrType(e,n)}getInteractionPlugin(e){return e.plugins.interaction}get assets(){}isRendererDestroyed(e){return!e.gl}installRendererPlugin(e,t){p.Renderer.registerPlugin(e,t)}installLoaderPlugin(e,t){Se.Loader.registerPlugin(t)}render(e,t,n){e.render(t,n)}}class ft extends dt{render(e,t,n){e.render(t,{renderTexture:n})}}class _t extends ft{installRendererPlugin(e,t){t.extension={type:L.get(F,"ExtensionType").RendererPlugin,name:e},L.get(F,"extensions").add(t)}installLoaderPlugin(e,t){t.extension={type:L.get(F,"ExtensionType").Loader,name:e},L.get(F,"extensions").add(t)}}class Kt extends _t{setLoaderResourceExtensionType(e,t){}getInteractionPlugin(e){}get assets(){return Wt.Assets}isRendererDestroyed(e){return"_systemsHash"in e?Object.keys(e._systemsHash).length===0:!1}installRendererPlugin(e,t){t.extension={type:[L.get(F,"ExtensionType").RendererPlugin],name:e},L.get(F,"extensions").add(t)}installLoaderPlugin(e,t){t.extension={type:[L.get(F,"ExtensionType").Loader,L.get(F,"ExtensionType").LoadParser],name:e},L.get(F,"extensions").add(t)}}const qt="VERSION"in F&&L.get(F,"VERSION").startsWith("7"),Yt="extensions"in F,Zt="ArrayResource"in F,C=qt?new Kt:Yt?new _t:Zt?new ft:new dt;class D{constructor(e,t=[],n=[]){this.descriptor=e,this.buffers=t,this.images=n}static load(e,t,n){let i=new D(e);return er(e,a=>{a.forEach(s=>i.buffers.push(s)),mt(e,a,s=>{s.forEach(o=>i.images.push(o)),n&&n(i)},t)},t),i}static isValidBuffer(e){const t=new Uint32Array(e,0,3);return t[0]===1179937895&&t[1]===2}static isEmbeddedResource(e){return e&&e.startsWith("data:")}static fromBuffer(e,t){const n=[];let i=12;for(;i<e.byteLength;){const l=new Uint32Array(e,i,3);n.push({length:l[0],type:l[1],offset:i+8}),i+=l[0]+8}const a=new Uint8Array(e,n[0].offset,n[0].length),s=JSON.parse(new TextDecoder("utf-8").decode(a)),o=[];for(let l=1;l<n.length;l++)o.push(e.slice(n[l].offset,n[l].offset+n[l].length));mt(s,o,l=>{t(new D(s,o,l))})}static async fromURL(e,t){if(!C.assets)throw new Error("PIXI3D: This feature is only available when using PixiJS v7+");const n=await me.settings.ADAPTER.fetch(e,t);return new Promise(async i=>{if(e.includes(".glb")){let a=await n.arrayBuffer();D.fromBuffer(a,s=>{i(s)})}else{let a=await n.json();D.load(a,new $t(e),s=>{i(s)})}})}}class $t{constructor(e){this.parentURL=e}load(e,t){const n=this.parentURL.substring(0,this.parentURL.lastIndexOf("/")+1)+e;(async()=>{if(!C.assets)throw new Error("PIXI3D: Assets are not available in current version of PixiJS.");let i={};if(n.includes(".bin")){const a=await me.settings.ADAPTER.fetch(n);i.data=await a.arrayBuffer()}else{let a=await C.assets.load(n);a&&(i.texture=a)}t(i)})()}}function mt(r,e,t,n){const i=[];if(!r.images||r.images.length===0)return t(i);let a=r.images.filter(c=>typeof c.bufferView!="number"&&D.isEmbeddedResource(c.uri)).map((c,f)=>f),s=r.images.filter(c=>typeof c.bufferView!="number"&&!D.isEmbeddedResource(c.uri)).map((c,f)=>f),o=r.images.filter(c=>typeof c.bufferView=="number").map((c,f)=>f);for(let c=0;c<a.length;c++){let f=a[c],m=r.images[f];i[f]=p.Texture.from(m.uri)}if(o.length===0&&s.length===0)return t(i);if(s.length>0&&!n)throw new Error("PIXI3D: A resource loader is required when image is external.");const l=(c,f,m)=>{n==null||n.load(c.uri,_=>{_.texture&&(i[f]=_.texture,m())})},h=(c,f,m)=>{tr(c,r,e,_=>{i[f]=_,m()})};let u=s.length,d=o.length;for(let c=0;c<s.length;c++){let f=s[c],m=r.images[f];l(m,f,()=>{--u===0&&d===0&&t(i)})}for(let c=0;c<o.length;c++){let f=o[c],m=r.images[f];h(m,f,()=>{--d===0&&u===0&&t(i)})}}function er(r,e,t){const n=[],i=r.buffers.filter(l=>D.isEmbeddedResource(l.uri)).map((l,h)=>h);for(let l=0;l<i.length;l++){let h=i[l],u=r.buffers[h];n[h]=rr(u.uri)}const a=r.buffers.filter(l=>!D.isEmbeddedResource(l.uri)).map((l,h)=>h);if(a.length===0)return e(n);if(!t)throw new Error("PIXI3D: A resource loader is required when buffer is not embedded.");const s=(l,h,u)=>{t.load(l,d=>{n[h]=d.data,u()})};let o=a.length;for(let l=0;l<a.length;l++){let h=a[l],u=r.buffers[h];s(u.uri,h,()=>{--o===0&&e(n)})}}function tr(r,e,t,n){const i=e.bufferViews[r.bufferView],a=new Uint8Array(t[i.buffer],i.byteOffset,i.byteLength),s=new Blob([a],{type:r.mimeType}),o=new FileReader;o.onload=()=>{n(p.Texture.from(o.result))},o.readAsDataURL(s)}function rr(r){return Uint8Array.from(atob(r.split(",")[1]),e=>e.charCodeAt(0)).buffer}const gt={use:function(r,e){if(r.extension!=="gltf")return e();let t=this;D.load(r.data,new nr(t,r),n=>{Object.assign(r,{gltf:n}),e()})},add:function(){C.setLoaderResourceExtensionType("bin",ae.buffer),C.setLoaderResourceExtensionType("gltf",ae.json)},test(r){return r.includes(".gltf")||r.includes(".glb")},async load(r){return await D.fromURL(r)}};C.installLoaderPlugin("gltf",gt);class nr{constructor(e,t){this._loader=e,this._resource=t}load(e,t){const n=this._resource.url.substring(0,this._resource.url.lastIndexOf("/")+1)+e;if(!this._loader.resources[n])this._loader.add({parentResource:this._resource,url:n,onComplete:t});else if(this._loader.resources[n].data)t(this._loader.resources[n]);else{let i=this._loader.onProgress.add((a,s)=>{s.url===n&&(t(s),i.detach())})}}}const pt={use:function(r,e){if(r.extension!=="glb")return e();if(D.isValidBuffer(r.data))D.fromBuffer(r.data,t=>{Object.assign(r,{gltf:t}),e()});else return e()},add:function(){C.setLoaderResourceExtensionType("glb",ae.buffer)}};C.installLoaderPlugin("cubemap",pt);var ge=1e-6,B=typeof Float32Array!="undefined"?Float32Array:Array;Math.hypot||(Math.hypot=function(){for(var r=0,e=arguments.length;e--;)r+=arguments[e]*arguments[e];return Math.sqrt(r)});function ir(){var r=new B(9);return B!=Float32Array&&(r[1]=0,r[2]=0,r[3]=0,r[5]=0,r[6]=0,r[7]=0),r[0]=1,r[4]=1,r[8]=1,r}function ar(r,e,t){var n=e[0],i=e[1],a=e[2],s=e[3],o=e[4],l=e[5],h=e[6],u=e[7],d=e[8],c=t[0],f=t[1],m=t[2],_=t[3],g=t[4],T=t[5],M=t[6],S=t[7],w=t[8];return r[0]=c*n+f*s+m*h,r[1]=c*i+f*o+m*u,r[2]=c*a+f*l+m*d,r[3]=_*n+g*s+T*h,r[4]=_*i+g*o+T*u,r[5]=_*a+g*l+T*d,r[6]=M*n+S*s+w*h,r[7]=M*i+S*o+w*u,r[8]=M*a+S*l+w*d,r}function sr(){var r=new B(16);return B!=Float32Array&&(r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=0,r[12]=0,r[13]=0,r[14]=0),r[0]=1,r[5]=1,r[10]=1,r[15]=1,r}function or(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],r[9]=e[9],r[10]=e[10],r[11]=e[11],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15],r}function At(r){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function lr(r,e){if(r===e){var t=e[1],n=e[2],i=e[3],a=e[6],s=e[7],o=e[11];r[1]=e[4],r[2]=e[8],r[3]=e[12],r[4]=t,r[6]=e[9],r[7]=e[13],r[8]=n,r[9]=a,r[11]=e[14],r[12]=i,r[13]=s,r[14]=o}else r[0]=e[0],r[1]=e[4],r[2]=e[8],r[3]=e[12],r[4]=e[1],r[5]=e[5],r[6]=e[9],r[7]=e[13],r[8]=e[2],r[9]=e[6],r[10]=e[10],r[11]=e[14],r[12]=e[3],r[13]=e[7],r[14]=e[11],r[15]=e[15];return r}function hr(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=e[4],o=e[5],l=e[6],h=e[7],u=e[8],d=e[9],c=e[10],f=e[11],m=e[12],_=e[13],g=e[14],T=e[15],M=t*o-n*s,S=t*l-i*s,w=t*h-a*s,E=n*l-i*o,b=n*h-a*o,J=i*h-a*l,K=u*_-d*m,q=u*g-c*m,Y=u*T-f*m,Z=d*g-c*_,$=d*T-f*_,ee=c*T-f*g,N=M*ee-S*$+w*Z+E*Y-b*q+J*K;return N?(N=1/N,r[0]=(o*ee-l*$+h*Z)*N,r[1]=(i*$-n*ee-a*Z)*N,r[2]=(_*J-g*b+T*E)*N,r[3]=(c*b-d*J-f*E)*N,r[4]=(l*Y-s*ee-h*q)*N,r[5]=(t*ee-i*Y+a*q)*N,r[6]=(g*w-m*J-T*S)*N,r[7]=(u*J-c*w+f*S)*N,r[8]=(s*$-o*Y+h*K)*N,r[9]=(n*Y-t*$-a*K)*N,r[10]=(m*b-_*w+T*M)*N,r[11]=(d*w-u*b-f*M)*N,r[12]=(o*q-s*Z-l*K)*N,r[13]=(t*Z-n*q+i*K)*N,r[14]=(_*S-m*E-g*M)*N,r[15]=(u*E-d*S+c*M)*N,r):null}function ur(r,e,t){var n=e[0],i=e[1],a=e[2],s=e[3],o=e[4],l=e[5],h=e[6],u=e[7],d=e[8],c=e[9],f=e[10],m=e[11],_=e[12],g=e[13],T=e[14],M=e[15],S=t[0],w=t[1],E=t[2],b=t[3];return r[0]=S*n+w*o+E*d+b*_,r[1]=S*i+w*l+E*c+b*g,r[2]=S*a+w*h+E*f+b*T,r[3]=S*s+w*u+E*m+b*M,S=t[4],w=t[5],E=t[6],b=t[7],r[4]=S*n+w*o+E*d+b*_,r[5]=S*i+w*l+E*c+b*g,r[6]=S*a+w*h+E*f+b*T,r[7]=S*s+w*u+E*m+b*M,S=t[8],w=t[9],E=t[10],b=t[11],r[8]=S*n+w*o+E*d+b*_,r[9]=S*i+w*l+E*c+b*g,r[10]=S*a+w*h+E*f+b*T,r[11]=S*s+w*u+E*m+b*M,S=t[12],w=t[13],E=t[14],b=t[15],r[12]=S*n+w*o+E*d+b*_,r[13]=S*i+w*l+E*c+b*g,r[14]=S*a+w*h+E*f+b*T,r[15]=S*s+w*u+E*m+b*M,r}function cr(r,e,t){var n=t[0],i=t[1],a=t[2],s,o,l,h,u,d,c,f,m,_,g,T;return e===r?(r[12]=e[0]*n+e[4]*i+e[8]*a+e[12],r[13]=e[1]*n+e[5]*i+e[9]*a+e[13],r[14]=e[2]*n+e[6]*i+e[10]*a+e[14],r[15]=e[3]*n+e[7]*i+e[11]*a+e[15]):(s=e[0],o=e[1],l=e[2],h=e[3],u=e[4],d=e[5],c=e[6],f=e[7],m=e[8],_=e[9],g=e[10],T=e[11],r[0]=s,r[1]=o,r[2]=l,r[3]=h,r[4]=u,r[5]=d,r[6]=c,r[7]=f,r[8]=m,r[9]=_,r[10]=g,r[11]=T,r[12]=s*n+u*i+m*a+e[12],r[13]=o*n+d*i+_*a+e[13],r[14]=l*n+c*i+g*a+e[14],r[15]=h*n+f*i+T*a+e[15]),r}function dr(r,e,t){var n=t[0],i=t[1],a=t[2];return r[0]=e[0]*n,r[1]=e[1]*n,r[2]=e[2]*n,r[3]=e[3]*n,r[4]=e[4]*i,r[5]=e[5]*i,r[6]=e[6]*i,r[7]=e[7]*i,r[8]=e[8]*a,r[9]=e[9]*a,r[10]=e[10]*a,r[11]=e[11]*a,r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15],r}function fr(r,e,t,n){var i=n[0],a=n[1],s=n[2],o=Math.hypot(i,a,s),l,h,u,d,c,f,m,_,g,T,M,S,w,E,b,J,K,q,Y,Z,$,ee,N,Re;return o<ge?null:(o=1/o,i*=o,a*=o,s*=o,l=Math.sin(t),h=Math.cos(t),u=1-h,d=e[0],c=e[1],f=e[2],m=e[3],_=e[4],g=e[5],T=e[6],M=e[7],S=e[8],w=e[9],E=e[10],b=e[11],J=i*i*u+h,K=a*i*u+s*l,q=s*i*u-a*l,Y=i*a*u-s*l,Z=a*a*u+h,$=s*a*u+i*l,ee=i*s*u+a*l,N=a*s*u-i*l,Re=s*s*u+h,r[0]=d*J+_*K+S*q,r[1]=c*J+g*K+w*q,r[2]=f*J+T*K+E*q,r[3]=m*J+M*K+b*q,r[4]=d*Y+_*Z+S*$,r[5]=c*Y+g*Z+w*$,r[6]=f*Y+T*Z+E*$,r[7]=m*Y+M*Z+b*$,r[8]=d*ee+_*N+S*Re,r[9]=c*ee+g*N+w*Re,r[10]=f*ee+T*N+E*Re,r[11]=m*ee+M*N+b*Re,e!==r&&(r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r)}function _r(r,e,t){var n=Math.sin(t),i=Math.cos(t),a=e[4],s=e[5],o=e[6],l=e[7],h=e[8],u=e[9],d=e[10],c=e[11];return e!==r&&(r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r[4]=a*i+h*n,r[5]=s*i+u*n,r[6]=o*i+d*n,r[7]=l*i+c*n,r[8]=h*i-a*n,r[9]=u*i-s*n,r[10]=d*i-o*n,r[11]=c*i-l*n,r}function mr(r,e,t){var n=Math.sin(t),i=Math.cos(t),a=e[0],s=e[1],o=e[2],l=e[3],h=e[8],u=e[9],d=e[10],c=e[11];return e!==r&&(r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r[0]=a*i-h*n,r[1]=s*i-u*n,r[2]=o*i-d*n,r[3]=l*i-c*n,r[8]=a*n+h*i,r[9]=s*n+u*i,r[10]=o*n+d*i,r[11]=l*n+c*i,r}function gr(r,e,t){var n=Math.sin(t),i=Math.cos(t),a=e[0],s=e[1],o=e[2],l=e[3],h=e[4],u=e[5],d=e[6],c=e[7];return e!==r&&(r[8]=e[8],r[9]=e[9],r[10]=e[10],r[11]=e[11],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r[0]=a*i+h*n,r[1]=s*i+u*n,r[2]=o*i+d*n,r[3]=l*i+c*n,r[4]=h*i-a*n,r[5]=u*i-s*n,r[6]=d*i-o*n,r[7]=c*i-l*n,r}function pr(r,e){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=e[0],r[13]=e[1],r[14]=e[2],r[15]=1,r}function Ar(r,e){return r[0]=e[0],r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=e[1],r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=e[2],r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function vr(r,e,t){var n=t[0],i=t[1],a=t[2],s=Math.hypot(n,i,a),o,l,h;return s<ge?null:(s=1/s,n*=s,i*=s,a*=s,o=Math.sin(e),l=Math.cos(e),h=1-l,r[0]=n*n*h+l,r[1]=i*n*h+a*o,r[2]=a*n*h-i*o,r[3]=0,r[4]=n*i*h-a*o,r[5]=i*i*h+l,r[6]=a*i*h+n*o,r[7]=0,r[8]=n*a*h+i*o,r[9]=i*a*h-n*o,r[10]=a*a*h+l,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r)}function Tr(r,e){return r[0]=e[12],r[1]=e[13],r[2]=e[14],r}function vt(r,e){var t=e[0],n=e[1],i=e[2],a=e[4],s=e[5],o=e[6],l=e[8],h=e[9],u=e[10];return r[0]=Math.hypot(t,n,i),r[1]=Math.hypot(a,s,o),r[2]=Math.hypot(l,h,u),r}function xr(r,e){var t=new B(3);vt(t,e);var n=1/t[0],i=1/t[1],a=1/t[2],s=e[0]*n,o=e[1]*i,l=e[2]*a,h=e[4]*n,u=e[5]*i,d=e[6]*a,c=e[8]*n,f=e[9]*i,m=e[10]*a,_=s+u+m,g=0;return _>0?(g=Math.sqrt(_+1)*2,r[3]=.25*g,r[0]=(d-f)/g,r[1]=(c-l)/g,r[2]=(o-h)/g):s>u&&s>m?(g=Math.sqrt(1+s-u-m)*2,r[3]=(d-f)/g,r[0]=.25*g,r[1]=(o+h)/g,r[2]=(c+l)/g):u>m?(g=Math.sqrt(1+u-s-m)*2,r[3]=(c-l)/g,r[0]=(o+h)/g,r[1]=.25*g,r[2]=(d+f)/g):(g=Math.sqrt(1+m-s-u)*2,r[3]=(o-h)/g,r[0]=(c+l)/g,r[1]=(d+f)/g,r[2]=.25*g),r}function Sr(r,e,t,n){var i=e[0],a=e[1],s=e[2],o=e[3],l=i+i,h=a+a,u=s+s,d=i*l,c=i*h,f=i*u,m=a*h,_=a*u,g=s*u,T=o*l,M=o*h,S=o*u,w=n[0],E=n[1],b=n[2];return r[0]=(1-(m+g))*w,r[1]=(c+S)*w,r[2]=(f-M)*w,r[3]=0,r[4]=(c-S)*E,r[5]=(1-(d+g))*E,r[6]=(_+T)*E,r[7]=0,r[8]=(f+M)*b,r[9]=(_-T)*b,r[10]=(1-(d+m))*b,r[11]=0,r[12]=t[0],r[13]=t[1],r[14]=t[2],r[15]=1,r}function wr(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=t+t,o=n+n,l=i+i,h=t*s,u=n*s,d=n*o,c=i*s,f=i*o,m=i*l,_=a*s,g=a*o,T=a*l;return r[0]=1-d-m,r[1]=u+T,r[2]=c-g,r[3]=0,r[4]=u-T,r[5]=1-h-m,r[6]=f+_,r[7]=0,r[8]=c+g,r[9]=f-_,r[10]=1-h-d,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function yr(r,e,t,n,i){var a=1/Math.tan(e/2),s;return r[0]=a/t,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=a,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=-1,r[12]=0,r[13]=0,r[15]=0,i!=null&&i!==1/0?(s=1/(n-i),r[10]=(i+n)*s,r[14]=2*i*n*s):(r[10]=-1,r[14]=-2*n),r}function Er(r,e,t,n,i,a,s){var o=1/(e-t),l=1/(n-i),h=1/(a-s);return r[0]=-2*o,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=-2*l,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=2*h,r[11]=0,r[12]=(e+t)*o,r[13]=(i+n)*l,r[14]=(s+a)*h,r[15]=1,r}function br(r,e,t,n){var i,a,s,o,l,h,u,d,c,f,m=e[0],_=e[1],g=e[2],T=n[0],M=n[1],S=n[2],w=t[0],E=t[1],b=t[2];return Math.abs(m-w)<ge&&Math.abs(_-E)<ge&&Math.abs(g-b)<ge?At(r):(u=m-w,d=_-E,c=g-b,f=1/Math.hypot(u,d,c),u*=f,d*=f,c*=f,i=M*c-S*d,a=S*u-T*c,s=T*d-M*u,f=Math.hypot(i,a,s),f?(f=1/f,i*=f,a*=f,s*=f):(i=0,a=0,s=0),o=d*s-c*a,l=c*i-u*s,h=u*a-d*i,f=Math.hypot(o,l,h),f?(f=1/f,o*=f,l*=f,h*=f):(o=0,l=0,h=0),r[0]=i,r[1]=o,r[2]=u,r[3]=0,r[4]=a,r[5]=l,r[6]=d,r[7]=0,r[8]=s,r[9]=h,r[10]=c,r[11]=0,r[12]=-(i*m+a*_+s*g),r[13]=-(o*m+l*_+h*g),r[14]=-(u*m+d*_+c*g),r[15]=1,r)}function Mr(r,e,t,n){var i=e[0],a=e[1],s=e[2],o=n[0],l=n[1],h=n[2],u=i-t[0],d=a-t[1],c=s-t[2],f=u*u+d*d+c*c;f>0&&(f=1/Math.sqrt(f),u*=f,d*=f,c*=f);var m=l*c-h*d,_=h*u-o*c,g=o*d-l*u;return f=m*m+_*_+g*g,f>0&&(f=1/Math.sqrt(f),m*=f,_*=f,g*=f),r[0]=m,r[1]=_,r[2]=g,r[3]=0,r[4]=d*g-c*_,r[5]=c*m-u*g,r[6]=u*_-d*m,r[7]=0,r[8]=u,r[9]=d,r[10]=c,r[11]=0,r[12]=i,r[13]=a,r[14]=s,r[15]=1,r}function ze(){var r=new B(3);return B!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),r}function Tt(r){var e=r[0],t=r[1],n=r[2];return Math.hypot(e,t,n)}function ke(r,e,t){var n=new B(3);return n[0]=r,n[1]=e,n[2]=t,n}function Rr(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r}function Ir(r,e,t,n){return r[0]=e,r[1]=t,r[2]=n,r}function Cr(r,e,t){return r[0]=e[0]+t[0],r[1]=e[1]+t[1],r[2]=e[2]+t[2],r}function Nr(r,e,t){return r[0]=e[0]-t[0],r[1]=e[1]-t[1],r[2]=e[2]-t[2],r}function Fr(r,e,t){return r[0]=e[0]*t[0],r[1]=e[1]*t[1],r[2]=e[2]*t[2],r}function Lr(r,e,t){return r[0]=e[0]*t,r[1]=e[1]*t,r[2]=e[2]*t,r}function Or(r,e){var t=e[0]-r[0],n=e[1]-r[1],i=e[2]-r[2];return Math.hypot(t,n,i)}function Pr(r,e){var t=e[0]-r[0],n=e[1]-r[1],i=e[2]-r[2];return t*t+n*n+i*i}function Ur(r){var e=r[0],t=r[1],n=r[2];return e*e+t*t+n*n}function Dr(r,e){return r[0]=-e[0],r[1]=-e[1],r[2]=-e[2],r}function Br(r,e){return r[0]=1/e[0],r[1]=1/e[1],r[2]=1/e[2],r}function xt(r,e){var t=e[0],n=e[1],i=e[2],a=t*t+n*n+i*i;return a>0&&(a=1/Math.sqrt(a)),r[0]=e[0]*a,r[1]=e[1]*a,r[2]=e[2]*a,r}function St(r,e){return r[0]*e[0]+r[1]*e[1]+r[2]*e[2]}function Ie(r,e,t){var n=e[0],i=e[1],a=e[2],s=t[0],o=t[1],l=t[2];return r[0]=i*l-a*o,r[1]=a*s-n*l,r[2]=n*o-i*s,r}function Gr(r,e,t,n){var i=e[0],a=e[1],s=e[2];return r[0]=i+n*(t[0]-i),r[1]=a+n*(t[1]-a),r[2]=s+n*(t[2]-s),r}function Vr(r,e,t){var n=e[0],i=e[1],a=e[2],s=t[3]*n+t[7]*i+t[11]*a+t[15];return s=s||1,r[0]=(t[0]*n+t[4]*i+t[8]*a+t[12])/s,r[1]=(t[1]*n+t[5]*i+t[9]*a+t[13])/s,r[2]=(t[2]*n+t[6]*i+t[10]*a+t[14])/s,r}function Hr(r,e,t){var n=t[0],i=t[1],a=t[2],s=t[3],o=e[0],l=e[1],h=e[2],u=i*h-a*l,d=a*o-n*h,c=n*l-i*o,f=i*c-a*d,m=a*u-n*c,_=n*d-i*u,g=s*2;return u*=g,d*=g,c*=g,f*=2,m*=2,_*=2,r[0]=o+u+f,r[1]=l+d+m,r[2]=h+c+_,r}var jr=Tt;(function(){var r=ze();return function(e,t,n,i,a,s){var o,l;for(t||(t=3),n||(n=0),i?l=Math.min(i*t+n,e.length):l=e.length,o=n;o<l;o+=t)r[0]=e[o],r[1]=e[o+1],r[2]=e[o+2],a(r,r,s),e[o]=r[0],e[o+1]=r[1],e[o+2]=r[2];return e}})();function zr(){var r=new B(4);return B!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0,r[3]=0),r}function wt(r,e,t,n){var i=new B(4);return i[0]=r,i[1]=e,i[2]=t,i[3]=n,i}function yt(r,e,t,n,i){return r[0]=e,r[1]=t,r[2]=n,r[3]=i,r}function kr(r,e){var t=e[0],n=e[1],i=e[2],a=e[3],s=t*t+n*n+i*i+a*a;return s>0&&(s=1/Math.sqrt(s)),r[0]=t*s,r[1]=n*s,r[2]=i*s,r[3]=a*s,r}function Qr(r,e,t){var n=e[0],i=e[1],a=e[2],s=e[3];return r[0]=t[0]*n+t[4]*i+t[8]*a+t[12]*s,r[1]=t[1]*n+t[5]*i+t[9]*a+t[13]*s,r[2]=t[2]*n+t[6]*i+t[10]*a+t[14]*s,r[3]=t[3]*n+t[7]*i+t[11]*a+t[15]*s,r}(function(){var r=zr();return function(e,t,n,i,a,s){var o,l;for(t||(t=4),n||(n=0),i?l=Math.min(i*t+n,e.length):l=e.length,o=n;o<l;o+=t)r[0]=e[o],r[1]=e[o+1],r[2]=e[o+2],r[3]=e[o+3],a(r,r,s),e[o]=r[0],e[o+1]=r[1],e[o+2]=r[2],e[o+3]=r[3];return e}})();function Qe(){var r=new B(4);return B!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),r[3]=1,r}function Wr(r,e,t){t=t*.5;var n=Math.sin(t);return r[0]=n*e[0],r[1]=n*e[1],r[2]=n*e[2],r[3]=Math.cos(t),r}function Xr(r,e,t){t*=.5;var n=e[0],i=e[1],a=e[2],s=e[3],o=Math.sin(t),l=Math.cos(t);return r[0]=n*l+s*o,r[1]=i*l+a*o,r[2]=a*l-i*o,r[3]=s*l-n*o,r}function Jr(r,e,t){t*=.5;var n=e[0],i=e[1],a=e[2],s=e[3],o=Math.sin(t),l=Math.cos(t);return r[0]=n*l-a*o,r[1]=i*l+s*o,r[2]=a*l+n*o,r[3]=s*l-i*o,r}function Kr(r,e,t){t*=.5;var n=e[0],i=e[1],a=e[2],s=e[3],o=Math.sin(t),l=Math.cos(t);return r[0]=n*l+i*o,r[1]=i*l-n*o,r[2]=a*l+s*o,r[3]=s*l-a*o,r}function Ce(r,e,t,n){var i=e[0],a=e[1],s=e[2],o=e[3],l=t[0],h=t[1],u=t[2],d=t[3],c,f,m,_,g;return f=i*l+a*h+s*u+o*d,f<0&&(f=-f,l=-l,h=-h,u=-u,d=-d),1-f>ge?(c=Math.acos(f),m=Math.sin(c),_=Math.sin((1-n)*c)/m,g=Math.sin(n*c)/m):(_=1-n,g=n),r[0]=_*i+g*l,r[1]=_*a+g*h,r[2]=_*s+g*u,r[3]=_*o+g*d,r}function qr(r,e){return r[0]=-e[0],r[1]=-e[1],r[2]=-e[2],r[3]=e[3],r}function Yr(r,e){var t=e[0]+e[4]+e[8],n;if(t>0)n=Math.sqrt(t+1),r[3]=.5*n,n=.5/n,r[0]=(e[5]-e[7])*n,r[1]=(e[6]-e[2])*n,r[2]=(e[1]-e[3])*n;else{var i=0;e[4]>e[0]&&(i=1),e[8]>e[i*3+i]&&(i=2);var a=(i+1)%3,s=(i+2)%3;n=Math.sqrt(e[i*3+i]-e[a*3+a]-e[s*3+s]+1),r[i]=.5*n,n=.5/n,r[3]=(e[a*3+s]-e[s*3+a])*n,r[a]=(e[a*3+i]+e[i*3+a])*n,r[s]=(e[s*3+i]+e[i*3+s])*n}return r}function Zr(r,e,t,n){var i=.5*Math.PI/180;e*=i,t*=i,n*=i;var a=Math.sin(e),s=Math.cos(e),o=Math.sin(t),l=Math.cos(t),h=Math.sin(n),u=Math.cos(n);return r[0]=a*l*u-s*o*h,r[1]=s*o*u+a*l*h,r[2]=s*l*h-a*o*u,r[3]=s*l*u+a*o*h,r}var $r=wt,en=yt,We=kr,tn=function(){var r=ze(),e=ke(1,0,0),t=ke(0,1,0);return function(n,i,a){var s=St(i,a);return s<-.999999?(Ie(r,e,i),jr(r)<1e-6&&Ie(r,t,i),xt(r,r),Wr(n,r,Math.PI),n):s>.999999?(n[0]=0,n[1]=0,n[2]=0,n[3]=1,n):(Ie(r,i,a),n[0]=r[0],n[1]=r[1],n[2]=r[2],n[3]=1+s,We(n,n))}}();(function(){var r=Qe(),e=Qe();return function(t,n,i,a,s,o){return Ce(r,n,s,o),Ce(e,i,a,o),Ce(t,r,e,2*o*(1-o)),t}})(),function(){var r=ir();return function(e,t,n,i){return r[0]=n[0],r[3]=n[1],r[6]=n[2],r[1]=i[0],r[4]=i[1],r[7]=i[2],r[2]=-t[0],r[5]=-t[1],r[8]=-t[2],We(e,Yr(e,r))}}();class x{static set(e,t,n,i=new Float32Array(3)){return Ir(i,e,t,n)}static fromValues(e,t,n){return ke(e,t,n)}static create(){return ze()}static add(e,t,n=new Float32Array(3)){return Cr(n,e,t)}static transformQuat(e,t,n=new Float32Array(3)){return Hr(n,e,t)}static subtract(e,t,n=new Float32Array(3)){return Nr(n,e,t)}static scale(e,t,n=new Float32Array(3)){return Lr(n,e,t)}static dot(e,t){return St(e,t)}static normalize(e,t=new Float32Array(3)){return xt(t,e)}static cross(e,t,n=new Float32Array(3)){return Ie(n,e,t)}static transformMat4(e,t,n=new Float32Array(3)){return Vr(n,e,t)}static copy(e,t=new Float32Array(3)){return Rr(t,e)}static magnitude(e){return Tt(e)}static squaredMagnitude(e){return Ur(e)}static inverse(e,t=new Float32Array(3)){return Br(t,e)}static negate(e,t=new Float32Array(3)){return Dr(t,e)}static multiply(e,t,n=new Float32Array(3)){return Fr(n,e,t)}static distance(e,t){return Or(e,t)}static squaredDistance(e,t){return Pr(e,t)}static lerp(e,t,n,i=new Float32Array(3)){return Gr(i,e,t,n)}}class P{static set(e,t,n,i,a=new Float32Array(4)){return en(a,e,t,n,i)}static fromValues(e,t,n,i){return $r(e,t,n,i)}static create(){return Qe()}static normalize(e,t=new Float32Array(4)){return We(t,e)}static slerp(e,t,n,i=new Float32Array(4)){return Ce(i,e,t,n)}static fromEuler(e,t,n,i=new Float32Array(4)){return Zr(i,e,t,n)}static conjugate(e,t=new Float32Array(4)){return qr(t,e)}static rotateX(e,t,n=new Float32Array(4)){return Xr(n,e,t)}static rotateY(e,t,n=new Float32Array(4)){return Jr(n,e,t)}static rotateZ(e,t,n=new Float32Array(4)){return Kr(n,e,t)}static rotationTo(e,t,n=new Float32Array(4)){return tn(n,e,t)}}const de=new Float32Array(4);class G extends U.ObservablePoint{constructor(e=0,t=0,n=0,i=1,a=()=>{},s=void 0){super(a,s),this._array=new Float32Array(4),this._array.set([e,t,n,i])}get array(){return this._array}set array(e){this.setFrom(e)}get x(){return this._array[0]}set x(e){this._array[0]!==e&&(this._array[0]=e,this.cb.call(this.scope))}get y(){return this._array[1]}set y(e){this._array[1]!==e&&(this._array[1]=e,this.cb.call(this.scope))}get z(){return this._array[2]}set z(e){this._array[2]!==e&&(this._array[2]=e,this.cb.call(this.scope))}get w(){return this._array[3]}set w(e){this._array[3]!==e&&(this._array[3]=e,this.cb.call(this.scope))}setEulerAngles(e,t,n){P.fromEuler(e,t,n,this._array),this.cb.call(this.scope)}clone(e=this.cb,t=this.scope){return new G(this.x,this.y,this.z,this.w,e,t)}copyFrom(e){return(this._array[0]!==e.x||this._array[1]!==e.y||this._array[2]!==e.z||this._array[3]!==e.w)&&(this._array[0]=e.x,this._array[1]=e.y,this._array[2]=e.z,this._array[3]=e.w,this.cb.call(this.scope)),this}copyTo(e){return e instanceof G&&e.set(this.x,this.y,this.z,this.w),e}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}set(e,t=e,n=e,i=e){return(this._array[0]!==e||this._array[1]!==t||this._array[2]!==n||this._array[3]!==i)&&(this._array[0]=e,this._array[1]=t,this._array[2]=n,this._array[3]=i,this.cb.call(this.scope)),this}setFrom(e){return this.set(e[0],e[1],e[2],e[3]),this}normalize(e=new G){return e.setFrom(P.normalize(this._array,de))}static slerp(e,t,n,i=new G){return i.setFrom(P.slerp(e.array,t.array,n,de))}static fromEuler(e,t,n,i=new G){return i.setFrom(P.fromEuler(e,t,n,de))}static conjugate(e,t=new G){return t.setFrom(P.conjugate(e.array,de))}static rotateX(e,t,n=new G){return n.setFrom(P.rotateX(e.array,t,de))}static rotateY(e,t,n=new G){return n.setFrom(P.rotateY(e.array,t,de))}static rotateZ(e,t,n=new G){return n.setFrom(P.rotateZ(e.array,t,de))}}class v{static getTranslation(e,t=new Float32Array(3)){return Tr(t,e)}static create(){return sr()}static translate(e,t,n=new Float32Array(16)){return cr(n,e,t)}static getScaling(e,t=new Float32Array(3)){return vt(t,e)}static getRotation(e,t=new Float32Array(4)){return xr(t,e)}static copy(e,t=new Float32Array(16)){return or(t,e)}static fromQuat(e,t=new Float32Array(16)){return wr(t,e)}static fromRotationTranslationScale(e,t,n,i=new Float32Array(16)){return Sr(i,e,t,n)}static fromRotation(e,t,n=new Float32Array(16)){return vr(n,e,t)}static fromScaling(e,t=new Float32Array(16)){return Ar(t,e)}static fromTranslation(e,t=new Float32Array(16)){return pr(t,e)}static multiply(e,t,n=new Float32Array(16)){return ur(n,e,t)}static lookAt(e,t,n,i=new Float32Array(16)){return br(i,e,t,n)}static identity(e=new Float32Array(16)){return At(e)}static perspective(e,t,n,i,a=new Float32Array(16)){return yr(a,e,t,n,i)}static ortho(e,t,n,i,a,s,o=new Float32Array(16)){return Er(o,e,t,n,i,a,s)}static invert(e,t=new Float32Array(16)){return hr(t,e)}static transpose(e,t=new Float32Array(16)){return lr(t,e)}static targetTo(e,t,n,i=new Float32Array(16)){return Mr(i,e,t,n)}static rotateX(e,t,n=new Float32Array(16)){return _r(n,e,t)}static rotateY(e,t,n=new Float32Array(16)){return mr(n,e,t)}static rotateZ(e,t,n=new Float32Array(16)){return gr(n,e,t)}static rotate(e,t,n,i=new Float32Array(16)){return fr(i,e,t,n)}static scale(e,t,n=new Float32Array(16)){return dr(n,e,t)}}class j{constructor(e,t,n){this._parent=e,this._data=t,this._update=n}get data(){return this._id!==this._parent.transformId&&(this._update(this._data),this._id=this._parent.transformId),this._data}}const O=new Float32Array(16);class I extends U.Matrix{constructor(e){super(),this._transformId=0,e?this.array=new Float32Array(e):this.array=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}get transformId(){return this._transformId}toArray(e,t){return e?v.transpose(this.array,t):t?v.copy(this.array,t):this.array}get position(){return this._position||(this._position=new j(this,new y,e=>{v.getTranslation(this.array,e.array)})),this._position.data}get scaling(){return this._scaling||(this._scaling=new j(this,new y,e=>{v.getScaling(this.array,e.array)})),this._scaling.data}get rotation(){if(!this._rotation){let e=new Float32Array(16);this._rotation=new j(this,new G,t=>{for(let n of[0,1,2])e[n+0]=this.array[n+0]/this.scaling.x,e[n+4]=this.array[n+4]/this.scaling.y,e[n+8]=this.array[n+8]/this.scaling.z;P.normalize(v.getRotation(e,t.array),t.array)})}return this._rotation.data}get up(){return this._up||(this._up=new j(this,new y,e=>{x.normalize(x.set(this.array[4],this.array[5],this.array[6],e.array),e.array)})),this._up.data}get down(){return this._down||(this._down=new j(this,new y,e=>{x.negate(this.up.array,e.array)})),this._down.data}get right(){return this._right||(this._right=new j(this,new y,e=>{x.negate(this.left.array,e.array)})),this._right.data}get left(){return this._left||(this._left=new j(this,new y,e=>{x.normalize(x.cross(this.up.array,this.forward.array,e.array),e.array)})),this._left.data}get forward(){return this._forward||(this._forward=new j(this,new y,e=>{x.normalize(x.set(this.array[8],this.array[9],this.array[10],e.array),e.array)})),this._forward.data}get backward(){return this._backward||(this._backward=new j(this,new y,e=>{x.negate(this.forward.array,e.array)})),this._backward.data}copyFrom(e){return e instanceof I&&(v.copy(e.array,this.array),this._transformId++),this}setFrom(e){return v.copy(e,this.array),this._transformId++,this}setFromRotationPositionScale(e,t,n){v.fromRotationTranslationScale(e.array,t.array,n.array,this.array),this._transformId++}multiply(e){v.multiply(e.array,this.array,this.array),this._transformId++}static translate(e,t,n=new I){return n.setFrom(v.translate(e.array,t.array,O))}static fromQuaternion(e,t=new I){return t.setFrom(v.fromQuat(e.array,O))}static fromRotationTranslationScale(e,t,n,i=new I){return i.setFrom(v.fromRotationTranslationScale(e.array,t.array,n.array,O))}static fromRotation(e,t,n=new I){return n.setFrom(v.fromRotation(e,t.array,O))}static fromScaling(e,t=new I){return t.setFrom(v.fromScaling(e.array,O))}static fromTranslation(e,t=new I){return t.setFrom(v.fromTranslation(e.array,O))}static lookAt(e,t,n,i=new I){return i.setFrom(v.lookAt(e.array,t.array,n.array,O))}static identity(e=new I){return e.setFrom(v.identity(O))}static perspective(e,t,n,i,a=new I){return a.setFrom(v.perspective(e,t,n,i,O))}static ortho(e,t,n,i,a,s,o=new I){return o.setFrom(v.ortho(e,t,n,i,a,s,O))}static invert(e,t=new I){return t.setFrom(v.invert(e.array,O))}static transpose(e,t=new I){return t.setFrom(v.transpose(e.array,O))}static targetTo(e,t,n,i=new I){return i.setFrom(v.targetTo(e.array,t.array,n.array,O))}static rotateX(e,t,n=new I){return n.setFrom(v.rotateX(e.array,t,O))}static rotateY(e,t,n=new I){return n.setFrom(v.rotateY(e.array,t,O))}static rotateZ(e,t,n=new I){return n.setFrom(v.rotateZ(e.array,t,O))}static rotate(e,t,n,i=new I){return i.setFrom(v.rotate(e.array,t,n.array,O))}static scale(e,t,n=new I){return n.setFrom(v.scale(e.array,t.array,O))}}const Q=new Float32Array(3);class y extends U.ObservablePoint{constructor(e=0,t=0,n=0,i=()=>{},a=void 0){super(i,a),this._array=new Float32Array(3),this._array.set([e,t,n])}get array(){return this._array}set array(e){this.setFrom(e)}get x(){return this._array[0]}set x(e){this._array[0]!==e&&(this._array[0]=e,this.cb.call(this.scope))}get y(){return this._array[1]}set y(e){this._array[1]!==e&&(this._array[1]=e,this.cb.call(this.scope))}get z(){return this._array[2]}set z(e){this._array[2]!==e&&(this._array[2]=e,this.cb.call(this.scope))}clone(e=this.cb,t=this.scope){return new y(this.x,this.y,this.z,e,t)}copyFrom(e){return(this._array[0]!==e.x||this._array[1]!==e.y||this._array[2]!==e.z)&&(this._array[0]=e.x,this._array[1]=e.y,this._array[2]=e.z,this.cb.call(this.scope)),this}copyTo(e){return e instanceof y&&e.set(this.x,this.y,this.z),e}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}set(e,t=e,n=e){return(this._array[0]!==e||this._array[1]!==t||this._array[2]!==n)&&(this._array[0]=e,this._array[1]=t,this._array[2]=n,this.cb.call(this.scope)),this}setFrom(e){return this.set(e[0],e[1],e[2]),this}normalize(e=new y){return e.setFrom(x.normalize(this._array,Q))}get magnitude(){return x.magnitude(this._array)}static dot(e,t){return x.dot(e._array,t._array)}static add(e,t,n=new y){return n.setFrom(x.add(e._array,t._array,Q))}static subtract(e,t,n=new y){return n.setFrom(x.subtract(e._array,t._array,Q))}static cross(e,t,n=new y){return n.setFrom(x.cross(e._array,t._array,Q))}static inverse(e,t=new y){return t.setFrom(x.inverse(e._array,Q))}static distance(e,t){return x.distance(e._array,t._array)}static squaredDistance(e,t){return x.squaredDistance(e._array,t._array)}static multiply(e,t,n=new y){return n.setFrom(x.multiply(e._array,t._array,Q))}static negate(e,t=new y){return t.setFrom(x.negate(e._array,Q))}static transform(e,t,n=new y){return t instanceof I?n.setFrom(x.transformMat4(e._array,t.array,Q)):n.setFrom(x.transformQuat(e._array,t.array,Q))}static lerp(e,t,n,i=new y){return i.setFrom(x.lerp(e._array,t._array,n,Q))}static scale(e,t,n=new y){return n.setFrom(x.scale(e._array,t,Q))}}class Ne extends U.Transform{constructor(){super(...arguments),this.position=new y(0,0,0,this.onChange,this),this.scale=new y(1,1,1,this.onChange,this),this.rotationQuaternion=new G(0,0,0,1,this.onChange,this),this.worldTransform=new I,this.localTransform=new I,this.inverseWorldTransform=new I,this.normalTransform=new I}updateLocalTransform(){this._localID!==this._currentLocalID&&(this.localTransform.setFromRotationPositionScale(this.rotationQuaternion,this.position,this.scale),this._parentID=-1,this._currentLocalID=this._localID)}setFromMatrix(e){this.localTransform.copyFrom(e),this.position.copyFrom(this.localTransform.position),this.scale.copyFrom(this.localTransform.scaling),this.rotationQuaternion.copyFrom(this.localTransform.rotation)}updateTransform(e){this.updateLocalTransform(),!(e&&this._parentID===e._worldID)&&(this.worldTransform.copyFrom(this.localTransform),e instanceof Ne&&this.worldTransform.multiply(e.worldTransform),v.invert(this.worldTransform.array,this.inverseWorldTransform.array),v.transpose(this.inverseWorldTransform.array,this.normalTransform.array),this._worldID++,e&&(this._parentID=e._worldID))}lookAt(e,t=new Float32Array([0,1,0])){let n=v.getRotation(v.targetTo(e.array,this.worldTransform.position.array,t));this.rotationQuaternion.set(n[0],n[1],n[2],n[3])}}class V extends Xt.Container{constructor(){super(...arguments),this.transform=new Ne}set position(e){this.transform.position.copyFrom(e)}get position(){return this.transform.position}set scale(e){this.transform.scale.copyFrom(e)}get scale(){return this.transform.scale}set rotationQuaternion(e){this.transform.rotationQuaternion.copyFrom(e)}get rotationQuaternion(){return this.transform.rotationQuaternion}get z(){return this.transform.position.z}set z(e){this.transform.position.z=e}get localTransform(){return this.transform.localTransform}get worldTransform(){return this.transform.worldTransform}}class Xe{constructor(e,t){this._direction=new y,this._origin=new y,this._origin.copyFrom(e),this._direction.copyFrom(t)}get origin(){return this._origin}get direction(){return this._direction}getPoint(e,t=new y){return y.add(this._origin,y.scale(this._direction,e,t),t)}}class we{static set(e,t,n,i,a=new Float32Array(4)){return yt(a,e,t,n,i)}static transformMat4(e,t,n=new Float32Array(4)){return Qr(n,e,t)}static fromValues(e,t,n,i){return wt(e,t,n,i)}}const rn=new Float32Array(3),nn=new Float32Array(16),ye=new Float32Array(4);class H extends V{constructor(e){super(),this.renderer=e,this._transformId=0,this._orthographic=!1,this._orthographicSize=10,this._obliqueness=new U.ObservablePoint(()=>{this._transformId++},void 0),this._fieldOfView=60,this._near=.1,this._far=1e3;let t=e.width/e.height,n=-1;this.renderer.on("prerender",()=>{this._aspect||e.width/e.height!==t&&(this._transformId++,t=e.width/e.height),!this.parent&&n!==this.transform._localID&&(this.transform.updateTransform(),n=this.transform._localID)}),H.main||(H.main=this),this.transform.position.z=5,this.transform.rotationQuaternion.setEulerAngles(0,180,0)}get transformId(){return this.transform._worldID+this._transformId}get obliqueness(){return this._obliqueness}set obliqueness(e){this._obliqueness.copyFrom(e)}destroy(e){super.destroy(e),this===H.main&&(H.main=void 0)}get orthographicSize(){return this._orthographicSize}set orthographicSize(e){this._orthographicSize!==e&&(this._orthographicSize=e,this._transformId++)}get orthographic(){return this._orthographic}set orthographic(e){this._orthographic!==e&&(this._orthographic=e,this._transformId++)}screenToRay(e,t,n=this.renderer.screen){let i=this.screenToWorld(e,t,1,void 0,n);if(i)return this.orthographic?new Xe(i,this.worldTransform.forward):new Xe(this.worldTransform.position,y.subtract(i,this.worldTransform.position))}screenToWorld(e,t,n,i=new y,a=this.renderer.screen){var s;this.transform.updateTransform((s=this.parent)==null?void 0:s.transform);let o=this.far;this.far=n;let l=v.invert(this.viewProjection.array,nn);if(l===null)return;let h=we.set(e/a.width*2-1,(t/a.height*2-1)*-1,1,1,ye);this.far=o;let u=we.transformMat4(h,l,ye);u[3]=1/u[3];for(let d=0;d<3;d++)u[d]*=u[3];return i.set(u[0],u[1],u[2])}worldToScreen(e,t,n,i=new U.Point,a=this.renderer.screen){var s;this.transform.updateTransform((s=this.parent)==null?void 0:s.transform);let o=we.set(e,t,n,1,ye),l=we.transformMat4(we.transformMat4(o,this.view.array,ye),this.projection.array,ye);if(l[3]!==0)for(let h=0;h<3;h++)l[h]/=l[3];return i.set((l[0]+1)/2*a.width,a.height-(l[1]+1)/2*a.height)}get aspect(){return this._aspect}set aspect(e){this._aspect!==e&&(this._aspect=e,this._transformId++)}get fieldOfView(){return this._fieldOfView}set fieldOfView(e){this._fieldOfView!==e&&(this._fieldOfView=e,this._transformId++)}get near(){return this._near}set near(e){this._near!==e&&(this._near=e,this._transformId++)}get far(){return this._far}set far(e){this._far!==e&&(this._far=e,this._transformId++)}get projection(){return this._projection||(this._projection=new j(this,new I,e=>{const t=this._aspect||this.renderer.width/this.renderer.height;this._orthographic?v.ortho(-this._orthographicSize*t,this._orthographicSize*t,-this._orthographicSize,this._orthographicSize,this._near,this._far,e.array):(v.perspective(this._fieldOfView*U.DEG_TO_RAD,t,this._near,this._far,e.array),e.array[8]=this._obliqueness.x,e.array[9]=this._obliqueness.y)})),this._projection.data}get view(){return this._view||(this._view=new j(this,new I,e=>{const t=x.add(this.worldTransform.position.array,this.worldTransform.forward.array,rn);v.lookAt(this.worldTransform.position.array,t,this.worldTransform.up.array,e.array)})),this._view.data}get viewProjection(){return this._viewProjection||(this._viewProjection=new j(this,new I,e=>{v.multiply(this.projection.array,this.view.array,e.array)})),this._viewProjection.data}}C.installRendererPlugin("camera",H);class an{constructor(e,t=H.main){this.camera=t,this._grabbed=!1,this._dampingAngles=new U.ObservablePoint(()=>{},void 0,0,180),this._distance=5,this._dampingDistance=5,this._angles=new U.ObservablePoint(()=>{this._angles.x=Math.min(Math.max(-85,this._angles.x),85)},void 0,0,180),this.enableDamping=!1,this.dampingFactor=.1,this.target={x:0,y:0,z:0},this.allowControl=!0,this.camera.renderer.on("prerender",()=>{this.enableDamping&&(this._dampingAngles.x=this._dampingAngles.x+(this._angles.x-this._dampingAngles.x)*this.dampingFactor,this._dampingAngles.y=this._dampingAngles.y+(this._angles.y-this._dampingAngles.y)*this.dampingFactor,this._dampingDistance=this._dampingDistance+(this._distance-this._dampingDistance)*this.dampingFactor),this.updateCamera()});let n=C.getInteractionPlugin(this.camera.renderer);n&&n.on("mousedown",i=>{i.stopped||(this._grabbed=!0)}),e.addEventListener("mousedown",()=>{this._grabbed=!0}),e.addEventListener("mouseup",()=>{this._grabbed=!1}),e.addEventListener("mousemove",i=>{this.allowControl&&i.buttons===1&&this._grabbed&&(this._angles.x+=i.movementY*.5,this._angles.y-=i.movementX*.5)}),e.addEventListener("wheel",i=>{this.allowControl&&(this.distance+=i.deltaY*.01,i.preventDefault())})}get angles(){return this._angles}updateCamera(){let e=this.enableDamping?this._dampingAngles:this._angles,t=this.enableDamping?this._dampingDistance:this._distance,n=P.fromEuler(e.x,e.y,0,new Float32Array(4)),i=x.transformQuat(x.set(0,0,1,new Float32Array(3)),n,new Float32Array(3)),a=x.subtract(x.set(this.target.x,this.target.y,this.target.z,new Float32Array(3)),x.scale(i,t,new Float32Array(3)),new Float32Array(3));this.camera.position.set(a[0],a[1],a[2]),this.camera.rotationQuaternion.set(n[0],n[1],n[2],n[3])}get distance(){return this._distance}set distance(e){this._distance=Math.min(Math.max(e,.01),Number.MAX_SAFE_INTEGER)}}class pe{constructor(){this._shaderGeometry={}}getShaderGeometry(e){return this._shaderGeometry[e.name]}addShaderGeometry(e,t){this._shaderGeometry[e.name]=e.createShaderGeometry(this,t)}hasShaderGeometry(e,t){return this._shaderGeometry[e.name]?!t||t&&this._shaderGeometry[e.name].instanced:!1}destroy(){for(let e in this._shaderGeometry)this._shaderGeometry[e].destroy();this._shaderGeometry={}}}var Je;(r=>{function e(){return Object.assign(new pe,{positions:{buffer:new Float32Array([-1,0,1,1,0,-1,-1,0,-1,1,0,1])},indices:{buffer:new Uint8Array([0,1,2,0,3,1])},normals:{buffer:new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0])},uvs:[{buffer:new Float32Array([0,1,1,0,0,0,1,1])}]})}r.create=e})(Je||(Je={}));var Ke;(r=>{function e(){return Object.assign(new pe,{positions:{buffer:new Float32Array([-1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,-1,-1,1,-1,1,1,1])},indices:{buffer:new Uint8Array([0,1,2,0,3,1,4,5,6,4,7,5,8,9,10,8,11,9,12,13,14,12,15,13,16,17,18,16,19,17,20,21,22,20,23,21])},normals:{buffer:new Float32Array([-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0])},uvs:[{buffer:new Float32Array([.625,1,.375,.75,.375,1,.625,.75,.625,.75,.375,.5,.375,.75,.625,.5,.625,.5,.375,.25,.375,.5,.625,.25,.625,.25,.375,0,.375,.25,.625,0,.375,.25,.125,.5,.375,.5,.125,.25,.875,.25,.625,.5,.875,.5,.625,.25])}],tangents:{buffer:new Float32Array([0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,-1,0,0,1,-1,0,0,1,-1,0,0,1,-1,0,0,1])}})}r.create=e})(Ke||(Ke={}));var qe;(r=>{function e(){return Object.assign(new pe,{positions:{buffer:new Float32Array([-1,1,0,1,-1,0,-1,-1,0,1,1,0])},indices:{buffer:new Uint8Array([0,2,1,0,1,3])},normals:{buffer:new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1])},uvs:[{buffer:new Float32Array([0,0,1,1,0,1,1,0])}]})}r.create=e})(qe||(qe={}));class sn extends V{constructor(e,t){super(),this.mesh=e,this.material=t}destroy(e){super.destroy(e),this.mesh.removeInstance(this)}}var W=(r=>(r.spot="spot",r.directional="directional",r.point="point",r))(W||{}),re=(r=>(r.opaque="opaque",r.mask="mask",r.blend="blend",r))(re||{}),ne=(r=>(r.alpha="alpha",r.emissive="emissive",r.f0="f0",r.metallic="metallic",r.normal="normal",r.occlusion="occlusion",r.roughness="roughness",r))(ne||{}),z;(r=>{let e;function t(m){if(e!==void 0)return e;const _=m.gl;return e=_.getParameter(_.MAX_VERTEX_UNIFORM_VECTORS),e}r.getMaxVertexUniformVectors=t;let n;function i(m){return m.context.webGLVersion===2?!0:(n!==void 0||(n=!!m.gl.getExtension("OES_texture_float")),n)}r.isFloatingPointTextureSupported=i;let a;function s(m){if(m.context.webGLVersion===2)return!0;if(a!==void 0)return a;const _=m.gl,g=_.getExtension("OES_texture_half_float");if(!g)return!1;const T=_.createTexture();_.bindTexture(_.TEXTURE_2D,T),_.texImage2D(_.TEXTURE_2D,0,_.RGBA,8,8,0,_.RGBA,g.HALF_FLOAT_OES,null);const M=_.createFramebuffer();_.bindFramebuffer(_.FRAMEBUFFER,M);const S=_.COLOR_ATTACHMENT0;return _.framebufferTexture2D(_.FRAMEBUFFER,S,_.TEXTURE_2D,T,0),a=_.checkFramebufferStatus(_.FRAMEBUFFER)===_.FRAMEBUFFER_COMPLETE,a}r.isHalfFloatFramebufferSupported=s;let o;function l(m){if(m.context.webGLVersion===2)return!0;if(o!==void 0)return o;const _=m.gl;if(!_.getExtension("OES_texture_float"))return!1;const g=_.createTexture();_.bindTexture(_.TEXTURE_2D,g),_.texImage2D(_.TEXTURE_2D,0,_.RGBA,8,8,0,_.RGBA,_.FLOAT,null);const T=_.createFramebuffer();_.bindFramebuffer(_.FRAMEBUFFER,T);const M=_.COLOR_ATTACHMENT0;return _.framebufferTexture2D(_.FRAMEBUFFER,M,_.TEXTURE_2D,g,0),o=_.checkFramebufferStatus(_.FRAMEBUFFER)===_.FRAMEBUFFER_COMPLETE,o}r.isFloatFramebufferSupported=l;let h;function u(m){return h!==void 0||(h=m.gl.getExtension("OES_texture_float_linear")!==null),h}r.supportsFloatLinear=u;function d(m){return m.context.webGLVersion===2?!0:m.gl.getExtension("EXT_shader_texture_lod")!==null}r.isShaderTextureLodSupported=d;let c;function f(m){return c!==void 0||(c=m.gl.getExtension("ANGLE_instanced_arrays")!==void 0),c}r.isInstancingSupported=f})(z||(z={}));const Ye=L.get(F,"BufferResource")||L.get(F,"resources").BufferResource;class Ae extends p.Texture{constructor(e){let t=new Float32Array(e*16),n=new Ye(t,{width:4,height:e});super(new p.BaseTexture(n,{mipmap:R.MIPMAP_MODES.OFF,wrapMode:R.WRAP_MODES.CLAMP,scaleMode:R.SCALE_MODES.NEAREST,format:R.FORMATS.RGBA,type:R.TYPES.FLOAT,alphaMode:R.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,resolution:1})),this._buffer=t}static isSupported(e){return z.isFloatingPointTextureSupported(e)}updateBuffer(e){this._buffer.set(e),this.baseTexture.resource.update()}}A.Debug=void 0,(r=>{const e=[],t=new je.EventEmitter;function n(o,l,h){t.on(o,l,h)}r.on=n;function i(o,l){if(!e.includes(o)){e.push(o);let h=s(o,l);console.warn(`PIXI3D: ${h}`),t.emit("warn",h)}}r.warn=i;function a(o,l){if(!e.includes(o)){e.push(o);let h=s(o,l);console.error(`PIXI3D: ${h}`),t.emit("error",h)}}r.error=a;function s(o,l){let h=o,u;for(;(u=/{(\w*)}/g.exec(h))!==null&&l;)h=h.replace(u[0],l[u[1]]);return h}})(A.Debug||(A.Debug={}));var fe=(r=>(r.meshVertexSkinningFloatingPointTexturesNotSupported='Mesh is using vertex skinning but floating point textures is not supported on this device/environment. In case of errors, try changing the environment in PixiJS settings. Set "PIXI.settings.PREFER_ENV = PIXI.ENV.WEBGL2" before creating a renderer/application.',r.meshVertexSkinningNumberOfJointsNotSupported="Mesh is using vertex skinning but the number of joints ({joints}) is not supported on this device/environment. Max number of supported joints is {maxJoints}, try reducing the number of joints.",r.imageBasedLightingShaderTextureLodNotSupported='Image based lighting is used but shader texture lod is not supported on this device/environment, the material may not be displayed correctly. Try changing the environment in PixiJS settings. Set "PIXI.settings.PREFER_ENV = PIXI.ENV.WEBGL2" before creating a renderer/application.',r))(fe||{}),ve=(r=>(r.ldr="ldr",r.rgbe8="rgbe8",r))(ve||{}),Fe;(r=>{function e(i,a,s,o,l){let h=[];if(a.instances.length>0&&h.push("USE_INSTANCING 1"),i.context.webGLVersion===1&&h.push("WEBGL1 1"),i.context.webGLVersion===2&&h.push("WEBGL2 1"),s.colors&&(s.colors.componentCount===3?h.push("HAS_VERTEX_COLOR_VEC3 1"):h.push("HAS_VERTEX_COLOR_VEC4 1")),s.normals&&h.push("HAS_NORMALS 1"),s.uvs&&s.uvs[0]&&h.push("HAS_UV_SET1 1"),s.uvs&&s.uvs[1]&&h.push("HAS_UV_SET2 1"),s.tangents&&h.push("HAS_TANGENTS 1"),s.targets){for(let u=0;u<s.targets.length;u++)s.targets[u].positions&&h.push("HAS_TARGET_POSITION"+u),s.targets[u].normals&&h.push("HAS_TARGET_NORMAL"+u),s.targets[u].tangents&&h.push("HAS_TARGET_TANGENT"+u);a.targetWeights&&(h.push(`WEIGHT_COUNT ${a.targetWeights.length}`),h.push("USE_MORPHING 1"))}if(s.joints&&h.push("HAS_JOINT_SET1 1"),s.weights&&h.push("HAS_WEIGHT_SET1 1"),a.skin&&t(a,h,i),o.unlit&&h.push("MATERIAL_UNLIT 1"),h.push("MATERIAL_METALLICROUGHNESS 1"),l.lights.length>0&&(h.push(`LIGHT_COUNT ${l.lights.length}`),h.push("USE_PUNCTUAL 1")),l.imageBasedLighting){if(!l.imageBasedLighting.valid)return;z.isShaderTextureLodSupported(i)?h.push("USE_TEX_LOD 1"):A.Debug.warn(fe.imageBasedLightingShaderTextureLodNotSupported),h.push("USE_IBL 1"),l.imageBasedLighting.diffuse.cubemapFormat===ve.rgbe8&&h.push("USE_RGBE 1")}if(o.shadowCastingLight&&h.push("USE_SHADOW_MAPPING 1"),o.baseColorTexture){if(!o.baseColorTexture.valid)return;o.baseColorTexture.transform&&h.push("HAS_BASECOLOR_UV_TRANSFORM 1"),h.push("HAS_BASE_COLOR_MAP 1")}if(o.emissiveTexture){if(!o.emissiveTexture.valid)return;o.emissiveTexture.transform&&h.push("HAS_EMISSIVE_UV_TRANSFORM 1"),h.push("HAS_EMISSIVE_MAP 1")}if(o.normalTexture){if(!o.normalTexture.valid)return;o.normalTexture.transform&&h.push("HAS_NORMAL_UV_TRANSFORM 1"),h.push("HAS_NORMAL_MAP 1")}if(o.metallicRoughnessTexture){if(!o.metallicRoughnessTexture.valid)return;o.metallicRoughnessTexture.transform&&h.push("HAS_METALLICROUGHNESS_UV_TRANSFORM 1"),h.push("HAS_METALLIC_ROUGHNESS_MAP 1")}if(o.occlusionTexture){if(!o.occlusionTexture.valid)return;o.occlusionTexture.transform&&h.push("HAS_OCCLUSION_UV_TRANSFORM 1"),h.push("HAS_OCCLUSION_MAP 1")}switch(o.alphaMode){case re.opaque:{h.push("ALPHAMODE_OPAQUE 1");break}case re.mask:{h.push("ALPHAMODE_MASK 1");break}}switch(o.debugMode&&h.push("DEBUG_OUTPUT 1"),o.debugMode){case ne.alpha:{h.push("DEBUG_ALPHA 1");break}case ne.emissive:{h.push("DEBUG_EMISSIVE 1");break}case ne.f0:{h.push("DEBUG_F0 1");break}case ne.metallic:{h.push("DEBUG_METALLIC 1");break}case ne.normal:{h.push("DEBUG_NORMAL 1");break}case ne.occlusion:{h.push("DEBUG_OCCLUSION 1");break}case ne.roughness:{h.push("DEBUG_ROUGHNESS 1");break}}return h}r.build=e;function t(i,a,s){if(!i.skin)return;let o=20,l=z.getMaxVertexUniformVectors(s)-o,h=Math.floor(l/8),u=i.skin.joints.length<=h;const d=()=>{var f;a.push("USE_SKINNING 1"),a.push(`JOINT_COUNT ${(f=i.skin)==null?void 0:f.joints.length}`)},c=()=>{var f;a.push("USE_SKINNING 1"),a.push(`JOINT_COUNT ${(f=i.skin)==null?void 0:f.joints.length}`),a.push("USE_SKINNING_TEXTURE 1")};if(me.settings.PREFER_UNIFORMS_WHEN_UPLOADING_SKIN_JOINTS){if(u){d();return}if(Ae.isSupported(s)){c();return}else A.Debug.error(fe.meshVertexSkinningNumberOfJointsNotSupported,{joints:i.skin.joints.length,maxJoints:h})}else{if(Ae.isSupported(s)){c();return}A.Debug.warn(fe.meshVertexSkinningFloatingPointTexturesNotSupported),u?d():A.Debug.error(fe.meshVertexSkinningNumberOfJointsNotSupported,{joints:i.skin.joints.length,maxJoints:h})}}function n(i){return i.includes("USE_SKINNING_TEXTURE 1")}r.hasSkinningTextureFeature=n})(Fe||(Fe={}));class _e extends p.Shader{constructor(){super(...arguments),this._state=Object.assign(new p.State,{culling:!0,clockwiseFrontFace:!1,depthTest:!0})}get name(){return"mesh-shader"}createShaderGeometry(e,t){let n=new p.Geometry;return e.indices&&(e.indices.buffer.BYTES_PER_ELEMENT===1?n.addIndex(new p.Buffer(new Uint16Array(e.indices.buffer))):n.addIndex(new p.Buffer(e.indices.buffer))),e.positions&&n.addAttribute("a_Position",new p.Buffer(e.positions.buffer),3,!1,e.positions.componentType,e.positions.stride),e.uvs&&e.uvs[0]&&n.addAttribute("a_UV1",new p.Buffer(e.uvs[0].buffer),2,!1,e.uvs[0].componentType,e.uvs[0].stride),e.normals&&n.addAttribute("a_Normal",new p.Buffer(e.normals.buffer),3,!1,e.normals.componentType,e.normals.stride),e.tangents&&n.addAttribute("a_Tangent",new p.Buffer(e.tangents.buffer),4,!1,e.tangents.componentType,e.tangents.stride),e.colors&&n.addAttribute("a_Color",new p.Buffer(e.colors.buffer),e.colors.componentCount,!0,e.colors.componentType,e.colors.stride),n}render(e,t,n=this._state,i=R.DRAW_MODES.TRIANGLES){const a=e.instances.filter(l=>l.worldVisible&&l.renderable).length,s=e.instances.length>0;e.geometry.hasShaderGeometry(this,s)||e.geometry.addShaderGeometry(this,s);let o=e.geometry.getShaderGeometry(this);t.shader.bind(this,!1),t.state.set(n),t.geometry.bind(o,this),t.geometry.draw(i,void 0,void 0,a)}}class on{constructor(){this._maxInstances=200,this._modelMatrix=[new p.Buffer,new p.Buffer,new p.Buffer,new p.Buffer],this._normalMatrix=[new p.Buffer,new p.Buffer,new p.Buffer,new p.Buffer],this._baseColor=new p.Buffer,this.expandBuffers(this._maxInstances)}expandBuffers(e){for(;e>this._maxInstances;)this._maxInstances+=Math.floor(this._maxInstances*.5);for(let t=0;t<4;t++)this._modelMatrix[t].update(new Float32Array(4*this._maxInstances)),this._normalMatrix[t].update(new Float32Array(4*this._maxInstances));this._baseColor.update(new Float32Array(4*this._maxInstances))}updateBuffers(e){e.length>this._maxInstances&&this.expandBuffers(e.length);let t=0;for(let n=0;n<e.length;n++){const i=e[n].transform.normalTransform.array;for(let o=0;o<4;o++)this._normalMatrix[o].data.set(i.slice(o*4,o*4+4),t*4);const a=e[n].worldTransform.array;for(let o=0;o<4;o++)this._modelMatrix[o].data.set(a.slice(o*4,o*4+4),t*4);const s=e[n].material;this._baseColor.data.set(s.baseColor.rgba,t*4),t++}for(let n=0;n<4;n++)this._modelMatrix[n].update(),this._normalMatrix[n].update();this._baseColor.update()}addGeometryAttributes(e){for(let t=0;t<4;t++)e.addAttribute(`a_ModelMatrix${t}`,this._modelMatrix[t],4,!1,void 0,0,void 0,!0);for(let t=0;t<4;t++)e.addAttribute(`a_NormalMatrix${t}`,this._normalMatrix[t],4,!1,void 0,0,void 0,!0);e.addAttribute("a_BaseColorFactor",this._baseColor,4,!1,void 0,0,void 0,!0)}}var se;(r=>{function e(t,n,i){return i.context.webGLVersion===1&&(t=t.replace(/VERSION/,"100").replace(/VERT_IN/g,"attribute").replace(/VERT_OUT/g,"varying").replace(/FRAG_COLOR/g,"gl_FragColor").replace(/FRAG_IN/g,"varying")),i.context.webGLVersion===2&&(t=t.replace(/VERSION/,"300 es").replace(/VERT_IN/g,"in").replace(/VERT_OUT/g,"out").replace(/FRAG_COLOR/g,"g_finalColor").replace(/FRAG_IN/g,"in")),t.replace(/#define FEATURES/,n.map(a=>`#define ${a}`).join(`
`))}r.build=e})(se||(se={}));var ln={source:`#version VERSION

//
// This fragment shader defines a reference implementation for Physically Based Shading of
// a microfacet surface material defined by a glTF model.
//
// References:
// [1] Real Shading in Unreal Engine 4
//     http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
// [2] Physically Based Shading at Disney
//     http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf
// [3] README.md - Environment Maps
//     https://github.com/KhronosGroup/glTF-WebGL-PBR/#environment-maps
// [4] "An Inexpensive BRDF Model for Physically based Rendering" by Christophe Schlick
//     https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf

#define FEATURES

#if defined(WEBGL1) //&& defined(USE_TEX_LOD)
#extension GL_EXT_shader_texture_lod : enable
#endif

#if defined(WEBGL1)
#extension GL_OES_standard_derivatives : enable
#endif

#if defined(WEBGL1) && defined(USE_HDR)
#extension GL_OES_texture_float : enable
#extension GL_OES_texture_float_linear : enable
#endif

#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
#else
  precision mediump float;
#endif

vec4 _texture(sampler2D sampler, vec2 coord)
{
#ifdef WEBGL2
    return texture(sampler, coord);
#else
    return texture2D(sampler, coord);
#endif
}

vec4 _texture(samplerCube sampler, vec3 coord)
{
#ifdef WEBGL2
    return texture(sampler, coord);
#else
    return textureCube(sampler, coord);
#endif
}
vec4 _textureLod(sampler2D sampler, vec2 coord, float lod)
{
#ifdef WEBGL2
    return textureLod(sampler, coord, lod);
#endif
#if defined(WEBGL1) && defined(GL_EXT_shader_texture_lod) 
    return texture2DLodEXT(sampler, coord, lod);
#endif
    return vec4(0.0);
}

vec4 _textureLod(samplerCube sampler, vec3 coord, float lod)
{
#ifdef WEBGL2
    return textureLod(sampler, coord, lod);
#endif
#if defined(WEBGL1) && defined(GL_EXT_shader_texture_lod) 
    return textureCubeLodEXT(sampler, coord, lod);
#endif
    return vec4(0.0);
}
vec3 _dFdx(vec3 coord)
{
#if defined(WEBGL2) || defined(GL_OES_standard_derivatives)
    return dFdx(coord);
#endif
    return vec3(0.0);
}

vec3 _dFdy(vec3 coord)
{
#if defined(WEBGL2) || defined(GL_OES_standard_derivatives)
    return dFdy(coord);
#endif
    return vec3(0.0);
}
FRAG_IN vec2 v_UVCoord1;
FRAG_IN vec2 v_UVCoord2;

// General Material
#ifdef HAS_NORMAL_MAP
uniform sampler2D u_NormalSampler;
uniform float u_NormalScale;
uniform int u_NormalUVSet;
uniform mat3 u_NormalUVTransform;
#endif

#ifdef HAS_EMISSIVE_MAP
uniform sampler2D u_EmissiveSampler;
uniform int u_EmissiveUVSet;
uniform vec3 u_EmissiveFactor;
uniform mat3 u_EmissiveUVTransform;
#endif

#ifdef HAS_OCCLUSION_MAP
uniform sampler2D u_OcclusionSampler;
uniform int u_OcclusionUVSet;
uniform float u_OcclusionStrength;
uniform mat3 u_OcclusionUVTransform;
#endif

// Metallic Roughness Material
#ifdef HAS_BASE_COLOR_MAP
uniform sampler2D u_BaseColorSampler;
uniform int u_BaseColorUVSet;
uniform mat3 u_BaseColorUVTransform;
#endif

#ifdef HAS_METALLIC_ROUGHNESS_MAP
uniform sampler2D u_MetallicRoughnessSampler;
uniform int u_MetallicRoughnessUVSet;
uniform mat3 u_MetallicRoughnessUVTransform;
#endif

// Specular Glossiness Material
#ifdef HAS_DIFFUSE_MAP
uniform sampler2D u_DiffuseSampler;
uniform int u_DiffuseUVSet;
uniform mat3 u_DiffuseUVTransform;
#endif

#ifdef HAS_SPECULAR_GLOSSINESS_MAP
uniform sampler2D u_SpecularGlossinessSampler;
uniform int u_SpecularGlossinessUVSet;
uniform mat3 u_SpecularGlossinessUVTransform;
#endif

// IBL
#ifdef USE_IBL
uniform samplerCube u_DiffuseEnvSampler;
uniform samplerCube u_SpecularEnvSampler;
uniform sampler2D u_brdfLUT;
#endif

#ifdef USE_SHADOW_MAPPING
uniform sampler2D u_ShadowSampler;
#endif

vec2 getNormalUV()
{
    vec3 uv = vec3(v_UVCoord1, 1.0);
#ifdef HAS_NORMAL_MAP
    uv.xy = u_NormalUVSet < 1 ? v_UVCoord1 : v_UVCoord2;
    #ifdef HAS_NORMAL_UV_TRANSFORM
    uv = u_NormalUVTransform * uv;
    #endif
#endif
    return uv.xy;
}

vec2 getEmissiveUV()
{
    vec3 uv = vec3(v_UVCoord1, 1.0);
#ifdef HAS_EMISSIVE_MAP
    uv.xy = u_EmissiveUVSet < 1 ? v_UVCoord1 : v_UVCoord2;
    #ifdef HAS_EMISSIVE_UV_TRANSFORM
    uv = u_EmissiveUVTransform * uv;
    #endif
#endif

    return uv.xy;
}

vec2 getOcclusionUV()
{
    vec3 uv = vec3(v_UVCoord1, 1.0);
#ifdef HAS_OCCLUSION_MAP
    uv.xy = u_OcclusionUVSet < 1 ? v_UVCoord1 : v_UVCoord2;
    #ifdef HAS_OCCLUSION_UV_TRANSFORM
    uv = u_OcclusionUVTransform * uv;
    #endif
#endif
    return uv.xy;
}

vec2 getBaseColorUV()
{
    vec3 uv = vec3(v_UVCoord1, 1.0);
#ifdef HAS_BASE_COLOR_MAP
    uv.xy = u_BaseColorUVSet < 1 ? v_UVCoord1 : v_UVCoord2;
    #ifdef HAS_BASECOLOR_UV_TRANSFORM
    uv = u_BaseColorUVTransform * uv;
    #endif
#endif
    return uv.xy;
}

vec2 getMetallicRoughnessUV()
{
    vec3 uv = vec3(v_UVCoord1, 1.0);
#ifdef HAS_METALLIC_ROUGHNESS_MAP
    uv.xy = u_MetallicRoughnessUVSet < 1 ? v_UVCoord1 : v_UVCoord2;
    #ifdef HAS_METALLICROUGHNESS_UV_TRANSFORM
    uv = u_MetallicRoughnessUVTransform * uv;
    #endif
#endif
    return uv.xy;
}

vec2 getSpecularGlossinessUV()
{
    vec3 uv = vec3(v_UVCoord1, 1.0);
#ifdef HAS_SPECULAR_GLOSSINESS_MAP
    uv.xy = u_SpecularGlossinessUVSet < 1 ? v_UVCoord1 : v_UVCoord2;
    #ifdef HAS_SPECULARGLOSSINESS_UV_TRANSFORM
    uv = u_SpecularGlossinessUVTransform * uv;
    #endif
#endif
    return uv.xy;
}

vec2 getDiffuseUV()
{
    vec3 uv = vec3(v_UVCoord1, 1.0);
#ifdef HAS_DIFFUSE_MAP
    uv.xy = u_DiffuseUVSet < 1 ? v_UVCoord1 : v_UVCoord2;
    #ifdef HAS_DIFFUSE_UV_TRANSFORM
    uv = u_DiffuseUVTransform * uv;
    #endif
#endif
    return uv.xy;
}

// textures.glsl needs to be included

const float M_PI = 3.141592653589793;
const float c_MinReflectance = 0.04;

FRAG_IN vec3 v_Position;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
FRAG_IN mat3 v_TBN;
#else
FRAG_IN vec3 v_Normal;
#endif
#endif

#ifdef HAS_VERTEX_COLOR_VEC3
FRAG_IN vec3 v_Color;
#endif
#ifdef HAS_VERTEX_COLOR_VEC4
FRAG_IN vec4 v_Color;
#endif

struct AngularInfo
{
    float NdotL;                  // cos angle between normal and light direction
    float NdotV;                  // cos angle between normal and view direction
    float NdotH;                  // cos angle between normal and half vector
    float LdotH;                  // cos angle between light direction and half vector

    float VdotH;                  // cos angle between view direction and half vector

    vec3 padding;
};

vec4 getVertexColor()
{
   vec4 color = vec4(1.0, 1.0, 1.0, 1.0);

#ifdef HAS_VERTEX_COLOR_VEC3
    color.rgb = v_Color;
#endif
#ifdef HAS_VERTEX_COLOR_VEC4
    color = v_Color;
#endif

   return color;
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
    vec2 UV = getNormalUV();

    // Retrieve the tangent space matrix
#ifndef HAS_TANGENTS
    vec3 pos_dx = _dFdx(v_Position);
    vec3 pos_dy = _dFdy(v_Position);
    vec3 tex_dx = _dFdx(vec3(UV, 0.0));
    vec3 tex_dy = _dFdy(vec3(UV, 0.0));
    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
    vec3 ng = normalize(v_Normal);
#else
    vec3 ng = cross(pos_dx, pos_dy);
#endif

    t = normalize(t - ng * dot(ng, t));
    vec3 b = normalize(cross(ng, t));
    mat3 tbn = mat3(t, b, ng);
#else // HAS_TANGENTS
    mat3 tbn = v_TBN;
#endif

#ifdef HAS_NORMAL_MAP
    vec3 n = _texture(u_NormalSampler, UV).rgb;
    n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));
#else
    // The tbn matrix is linearly interpolated, so we need to re-normalize
    vec3 n = normalize(tbn[2].xyz);
#endif

    return n;
}

float getPerceivedBrightness(vec3 vector)
{
    return sqrt(0.299 * vector.r * vector.r + 0.587 * vector.g * vector.g + 0.114 * vector.b * vector.b);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows/js/three.pbrUtilities.js#L34
float solveMetallic(vec3 diffuse, vec3 specular, float oneMinusSpecularStrength) {
    float specularBrightness = getPerceivedBrightness(specular);

    if (specularBrightness < c_MinReflectance) {
        return 0.0;
    }

    float diffuseBrightness = getPerceivedBrightness(diffuse);

    float a = c_MinReflectance;
    float b = diffuseBrightness * oneMinusSpecularStrength / (1.0 - c_MinReflectance) + specularBrightness - 2.0 * c_MinReflectance;
    float c = c_MinReflectance - specularBrightness;
    float D = b * b - 4.0 * a * c;

    return clamp((-b + sqrt(D)) / (2.0 * a), 0.0, 1.0);
}

AngularInfo getAngularInfo(vec3 pointToLight, vec3 normal, vec3 view)
{
    // Standard one-letter names
    vec3 n = normalize(normal);           // Outward direction of surface point
    vec3 v = normalize(view);             // Direction from surface point to view
    vec3 l = normalize(pointToLight);     // Direction from surface point to light
    vec3 h = normalize(l + v);            // Direction of the vector between l and v

    float NdotL = clamp(dot(n, l), 0.0, 1.0);
    float NdotV = clamp(dot(n, v), 0.0, 1.0);
    float NdotH = clamp(dot(n, h), 0.0, 1.0);
    float LdotH = clamp(dot(l, h), 0.0, 1.0);
    float VdotH = clamp(dot(v, h), 0.0, 1.0);

    return AngularInfo(
        NdotL,
        NdotV,
        NdotH,
        LdotH,
        VdotH,
        vec3(0, 0, 0)
    );
}

#ifdef USE_SHADOW_MAPPING
FRAG_IN vec4 v_PositionLightSpace;
#endif

float linstep(float low, float high, float v)
{
    return clamp((v-low) / (high-low), 0.0, 1.0);
}

#ifdef USE_SHADOW_MAPPING
float getShadowContribution()
{
    vec3 coords = v_PositionLightSpace.xyz / v_PositionLightSpace.w * 0.5 + 0.5;
    if (coords.z < 0.01 || coords.z > 0.99 || coords.x < 0.01 || coords.x > 0.99 || coords.y < 0.01 || coords.y > 0.99) {
        return 1.0;
    }
    vec2 moments = vec2(1.0) - _texture(u_ShadowSampler, coords.xy).xy;
    float p = step(coords.z, moments.x);
    float variance = max(moments.y - moments.x * moments.x, 0.00002);
    float d = coords.z - moments.x;
    float pMax = linstep(0.2, 1.0, variance / (variance + d*d));
    return min(max(p, pMax), 1.0);
}
#endif
uniform float u_Exposure;

const float GAMMA = 2.2;
const float INV_GAMMA = 1.0 / GAMMA;

// linear to sRGB approximation
// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html
vec3 LINEARtoSRGB(vec3 color)
{
    return pow(color, vec3(INV_GAMMA));
}

// sRGB to linear approximation
// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html
vec4 SRGBtoLINEAR(vec4 srgbIn)
{
    return vec4(pow(srgbIn.xyz, vec3(GAMMA)), srgbIn.w);
}

// Uncharted 2 tone map
// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/
vec3 toneMapUncharted2Impl(vec3 color)
{
    const float A = 0.15;
    const float B = 0.50;
    const float C = 0.10;
    const float D = 0.20;
    const float E = 0.02;
    const float F = 0.30;
    return ((color*(A*color+C*B)+D*E)/(color*(A*color+B)+D*F))-E/F;
}

vec3 toneMapUncharted(vec3 color)
{
    const float W = 11.2;
    color = toneMapUncharted2Impl(color * 2.0);
    vec3 whiteScale = 1.0 / toneMapUncharted2Impl(vec3(W));
    return LINEARtoSRGB(color * whiteScale);
}

// Hejl Richard tone map
// see: http://filmicworlds.com/blog/filmic-tonemapping-operators/
vec3 toneMapHejlRichard(vec3 color)
{
    color = max(vec3(0.0), color - vec3(0.004));
    return (color*(6.2*color+.5))/(color*(6.2*color+1.7)+0.06);
}

// ACES tone map
// see: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
vec3 toneMapACES(vec3 color)
{
    const float A = 2.51;
    const float B = 0.03;
    const float C = 2.43;
    const float D = 0.59;
    const float E = 0.14;
    return LINEARtoSRGB(clamp((color * (A * color + B)) / (color * (C * color + D) + E), 0.0, 1.0));
}

vec3 toneMap(vec3 color)
{
    color *= u_Exposure;

#ifdef TONEMAP_UNCHARTED
    return toneMapUncharted(color);
#endif

#ifdef TONEMAP_HEJLRICHARD
    return toneMapHejlRichard(color);
#endif

#ifdef TONEMAP_ACES
    return toneMapACES(color);
#endif

    return LINEARtoSRGB(color);
}

vec4 encodeRGBE(vec3 rgb) {
  vec4 vEncoded;
  float maxComponent = max(max(rgb.r, rgb.g), rgb.b);
  float fExp = ceil(log2(maxComponent));
  vEncoded.rgb = rgb / exp2(fExp);
  vEncoded.a = (fExp + 128.0) / 255.0;
  return vEncoded;
}

vec3 decodeRGBE(vec4 rgbe) {
  vec3 vDecoded;
  float fExp = rgbe.a * 255.0 - 128.0;
  vDecoded = rgbe.rgb * exp2(fExp);
  return vDecoded;
}

// KHR_lights_punctual extension.
// see https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual

struct Light
{
    vec3 direction;
    float range;

    vec3 color;
    float intensity;

    vec3 position;
    float innerConeCos;

    float outerConeCos;
    int type;

    vec2 padding;
};

const int LightType_Directional = 0;
const int LightType_Point = 1;
const int LightType_Spot = 2;

#ifdef USE_PUNCTUAL
uniform Light u_Lights[LIGHT_COUNT];
#endif

#if defined(MATERIAL_SPECULARGLOSSINESS) || defined(MATERIAL_METALLICROUGHNESS)
uniform float u_MetallicFactor;
uniform float u_RoughnessFactor;
uniform vec4 u_BaseColorFactor;
#endif

#ifdef USE_INSTANCING
FRAG_IN vec4 v_BaseColorFactor;
#endif

#ifdef MATERIAL_SPECULARGLOSSINESS
uniform vec3 u_SpecularFactor;
uniform vec4 u_DiffuseFactor;
uniform float u_GlossinessFactor;
#endif

#ifdef ALPHAMODE_MASK
uniform float u_AlphaCutoff;
#endif

#ifdef USE_SHADOW_MAPPING
uniform int u_ShadowLightIndex;
#endif

uniform vec3 u_Camera;

uniform int u_MipCount;

struct MaterialInfo
{
    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
    vec3 reflectance0;            // full reflectance color (normal incidence angle)

    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
    vec3 diffuseColor;            // color contribution from diffuse lighting

    vec3 reflectance90;           // reflectance color at grazing angle
    vec3 specularColor;           // color contribution from specular lighting
};

// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
#ifdef USE_IBL
vec3 getIBLContribution(MaterialInfo materialInfo, vec3 n, vec3 v)
{
    float NdotV = clamp(dot(n, v), 0.0, 1.0);

    float lod = clamp(materialInfo.perceptualRoughness * float(u_MipCount), 0.0, float(u_MipCount));
    vec3 reflection = normalize(reflect(-v, n));

    vec2 brdfSamplePoint = clamp(vec2(NdotV, materialInfo.perceptualRoughness), vec2(0.0, 0.0), vec2(1.0, 1.0));
    // retrieve a scale and bias to F0. See [1], Figure 3
    vec2 brdf = _texture(u_brdfLUT, brdfSamplePoint).rg;

    vec4 diffuseSample = _texture(u_DiffuseEnvSampler, n);

#ifdef USE_TEX_LOD
    vec4 specularSample = _textureLod(u_SpecularEnvSampler, reflection, lod);
#else
    vec4 specularSample = _texture(u_SpecularEnvSampler, reflection);
#endif

#if defined(USE_HDR)
    // Already linear.
    vec3 diffuseLight = diffuseSample.rgb;
    vec3 specularLight = specularSample.rgb;
#elif defined(USE_RGBE)
    vec3 diffuseLight = decodeRGBE(diffuseSample);
    vec3 specularLight = decodeRGBE(specularSample);
#else
    vec3 diffuseLight = SRGBtoLINEAR(diffuseSample).rgb;
    vec3 specularLight = SRGBtoLINEAR(specularSample).rgb;
#endif

    vec3 diffuse = diffuseLight * materialInfo.diffuseColor;
    vec3 specular = specularLight * (materialInfo.specularColor * brdf.x + brdf.y);

    return diffuse + specular;
}
#endif

// Lambert lighting
// see https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/
vec3 diffuse(MaterialInfo materialInfo)
{
    return materialInfo.diffuseColor / M_PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(MaterialInfo materialInfo, AngularInfo angularInfo)
{
    return materialInfo.reflectance0 + (materialInfo.reflectance90 - materialInfo.reflectance0) * pow(clamp(1.0 - angularInfo.VdotH, 0.0, 1.0), 5.0);
}

// Smith Joint GGX
// Note: Vis = G / (4 * NdotL * NdotV)
// see Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3
// see Real-Time Rendering. Page 331 to 336.
// see https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg)
float visibilityOcclusion(MaterialInfo materialInfo, AngularInfo angularInfo)
{
    float NdotL = angularInfo.NdotL;
    float NdotV = angularInfo.NdotV;
    float alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;

    float GGXV = NdotL * sqrt(NdotV * NdotV * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);
    float GGXL = NdotV * sqrt(NdotL * NdotL * (1.0 - alphaRoughnessSq) + alphaRoughnessSq);

    float GGX = GGXV + GGXL;
    if (GGX > 0.0)
    {
        return 0.5 / GGX;
    }
    return 0.0;
}

// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())
// Implementation from "Average Irregularity Representation of a Roughened Surface for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.
float microfacetDistribution(MaterialInfo materialInfo, AngularInfo angularInfo)
{
    float alphaRoughnessSq = materialInfo.alphaRoughness * materialInfo.alphaRoughness;
    float f = (angularInfo.NdotH * alphaRoughnessSq - angularInfo.NdotH) * angularInfo.NdotH + 1.0;
    return alphaRoughnessSq / (M_PI * f * f);
}

vec3 getPointShade(vec3 pointToLight, MaterialInfo materialInfo, vec3 normal, vec3 view)
{
    AngularInfo angularInfo = getAngularInfo(pointToLight, normal, view);

    if (angularInfo.NdotL > 0.0 || angularInfo.NdotV > 0.0)
    {
        // Calculate the shading terms for the microfacet specular shading model
        vec3 F = specularReflection(materialInfo, angularInfo);
        float Vis = visibilityOcclusion(materialInfo, angularInfo);
        float D = microfacetDistribution(materialInfo, angularInfo);

        // Calculation of analytical lighting contribution
        vec3 diffuseContrib = (1.0 - F) * diffuse(materialInfo);
        vec3 specContrib = F * Vis * D;

        // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
        return angularInfo.NdotL * (diffuseContrib + specContrib);
    }

    return vec3(0.0, 0.0, 0.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#range-property
float getRangeAttenuation(float range, float distance)
{
    if (range <= 0.0)
    {
        // negative range means unlimited
        return 1.0;
    }
    return max(min(1.0 - pow(distance / range, 4.0), 1.0), 0.0) / pow(distance, 2.0);
}

// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md#inner-and-outer-cone-angles
float getSpotAttenuation(vec3 pointToLight, vec3 spotDirection, float outerConeCos, float innerConeCos)
{
    float actualCos = dot(normalize(spotDirection), normalize(-pointToLight));
    if (actualCos > outerConeCos)
    {
        if (actualCos < innerConeCos)
        {
            return smoothstep(outerConeCos, innerConeCos, actualCos);
        }
        return 1.0;
    }
    return 0.0;
}

vec3 applyDirectionalLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view, float shadow)
{
    vec3 pointToLight = -light.direction;
    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view) * shadow;
    return light.intensity * light.color * shade;
}

vec3 applyPointLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view)
{
    vec3 pointToLight = light.position - v_Position;
    float distance = length(pointToLight);
    float attenuation = getRangeAttenuation(light.range, distance);
    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view);
    return attenuation * light.intensity * light.color * shade;
}

vec3 applySpotLight(Light light, MaterialInfo materialInfo, vec3 normal, vec3 view, float shadow)
{
    vec3 pointToLight = light.position - v_Position;
    float distance = length(pointToLight);
    float rangeAttenuation = getRangeAttenuation(light.range, distance);
    float spotAttenuation = getSpotAttenuation(pointToLight, light.direction, light.outerConeCos, light.innerConeCos);
    vec3 shade = getPointShade(pointToLight, materialInfo, normal, view) * shadow;
    return rangeAttenuation * spotAttenuation * light.intensity * light.color * shade;
}

#ifdef WEBGL2
    out vec4 FRAG_COLOR;
#endif

void main()
{
    // Metallic and Roughness material properties are packed together
    // In glTF, these factors can be specified by fixed scalar values
    // or from a metallic-roughness map
    float perceptualRoughness = 0.0;
    float metallic = 0.0;
    vec4 baseColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 diffuseColor = vec3(0.0);
    vec3 specularColor= vec3(0.0);
    vec3 f0 = vec3(0.04);

#ifdef MATERIAL_SPECULARGLOSSINESS

#ifdef HAS_SPECULAR_GLOSSINESS_MAP
    vec4 sgSample = SRGBtoLINEAR(_texture(u_SpecularGlossinessSampler, getSpecularGlossinessUV()));
    perceptualRoughness = (1.0 - sgSample.a * u_GlossinessFactor); // glossiness to roughness
    f0 = sgSample.rgb * u_SpecularFactor; // specular
#else
    f0 = u_SpecularFactor;
    perceptualRoughness = 1.0 - u_GlossinessFactor;
#endif // ! HAS_SPECULAR_GLOSSINESS_MAP

#ifdef HAS_DIFFUSE_MAP
    baseColor = SRGBtoLINEAR(_texture(u_DiffuseSampler, getDiffuseUV())) * u_DiffuseFactor;
#else
    baseColor = u_DiffuseFactor;
#endif // !HAS_DIFFUSE_MAP

    baseColor *= getVertexColor();

    // f0 = specular
    specularColor = f0;
    float oneMinusSpecularStrength = 1.0 - max(max(f0.r, f0.g), f0.b);
    diffuseColor = baseColor.rgb * oneMinusSpecularStrength;

#ifdef DEBUG_METALLIC
    // do conversion between metallic M-R and S-G metallic
    metallic = solveMetallic(baseColor.rgb, specularColor, oneMinusSpecularStrength);
#endif // ! DEBUG_METALLIC

#endif // ! MATERIAL_SPECULARGLOSSINESS

#ifdef MATERIAL_METALLICROUGHNESS

#ifdef HAS_METALLIC_ROUGHNESS_MAP
    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
    vec4 mrSample = _texture(u_MetallicRoughnessSampler, getMetallicRoughnessUV());
    perceptualRoughness = mrSample.g * u_RoughnessFactor;
    metallic = mrSample.b * u_MetallicFactor;
#else
    metallic = u_MetallicFactor;
    perceptualRoughness = u_RoughnessFactor;
#endif

    vec4 baseColorFactor = u_BaseColorFactor;
#ifdef USE_INSTANCING
    baseColorFactor = v_BaseColorFactor;
#endif

    // The albedo may be defined from a base texture or a flat color
#ifdef HAS_BASE_COLOR_MAP
    baseColor = SRGBtoLINEAR(_texture(u_BaseColorSampler, getBaseColorUV())) * baseColorFactor;
#else
    baseColor = baseColorFactor;
#endif

    baseColor *= getVertexColor();

    diffuseColor = baseColor.rgb * (vec3(1.0) - f0) * (1.0 - metallic);

    specularColor = mix(f0, baseColor.rgb, metallic);

#endif // ! MATERIAL_METALLICROUGHNESS

#ifdef ALPHAMODE_MASK
    if(baseColor.a < u_AlphaCutoff)
    {
        discard;
    }
    baseColor.a = 1.0;
#endif

#ifdef ALPHAMODE_OPAQUE
    baseColor.a = 1.0;
#endif

#ifdef MATERIAL_UNLIT
    FRAG_COLOR = vec4(LINEARtoSRGB(baseColor.rgb) * baseColor.a, baseColor.a);
    return;
#endif

    perceptualRoughness = clamp(perceptualRoughness, 0.0, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);

    // Roughness is authored as perceptual roughness; as is convention,
    // convert to material roughness by squaring the perceptual roughness [2].
    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    // Compute reflectance.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    vec3 specularEnvironmentR0 = specularColor.rgb;
    // Anything less than 2% is physically impossible and is instead considered to be shadowing. Compare to "Real-Time-Rendering" 4th editon on page 325.
    vec3 specularEnvironmentR90 = vec3(clamp(reflectance * 50.0, 0.0, 1.0));

    MaterialInfo materialInfo = MaterialInfo(
        perceptualRoughness,
        specularEnvironmentR0,
        alphaRoughness,
        diffuseColor,
        specularEnvironmentR90,
        specularColor
    );

    // LIGHTING

    vec3 color = vec3(0.0, 0.0, 0.0);
    vec3 normal = getNormal();
    vec3 view = normalize(u_Camera - v_Position);

    float shadow = 1.0;
    #ifdef USE_SHADOW_MAPPING
        shadow = getShadowContribution();
    #endif

#ifdef USE_PUNCTUAL
    for (int i = 0; i < LIGHT_COUNT; ++i)
    {
        float shadowContribution = shadow;
        #ifdef USE_SHADOW_MAPPING
        if (u_ShadowLightIndex != i) 
        {
            shadowContribution = 1.0;
        }
        #endif
        Light light = u_Lights[i];
        if (light.type == LightType_Directional)
        {
            color += applyDirectionalLight(light, materialInfo, normal, view, shadowContribution);
        }
        else if (light.type == LightType_Point)
        {
            color += applyPointLight(light, materialInfo, normal, view);
        }
        else if (light.type == LightType_Spot)
        {
            color += applySpotLight(light, materialInfo, normal, view, shadowContribution);
        }
    }
#endif

    // Calculate lighting contribution from image based lighting source (IBL)
#ifdef USE_IBL
    color += getIBLContribution(materialInfo, normal, view);
#endif

    float ao = 1.0;
    // Apply optional PBR terms for additional (optional) shading
#ifdef HAS_OCCLUSION_MAP
    ao = _texture(u_OcclusionSampler,  getOcclusionUV()).r;
    color = mix(color, color * ao, u_OcclusionStrength);
#endif

    vec3 emissive = vec3(0);
#ifdef HAS_EMISSIVE_MAP
    emissive = SRGBtoLINEAR(_texture(u_EmissiveSampler, getEmissiveUV())).rgb * u_EmissiveFactor;
    color += emissive;
#endif

#ifndef DEBUG_OUTPUT // no debug

    // regular shading
    FRAG_COLOR = vec4(toneMap(color) * baseColor.a, baseColor.a);

#else // debug output

    #ifdef DEBUG_METALLIC
        FRAG_COLOR.rgb = vec3(metallic);
    #endif

    #ifdef DEBUG_ROUGHNESS
        FRAG_COLOR.rgb = vec3(perceptualRoughness);
    #endif

    #ifdef DEBUG_NORMAL
        #ifdef HAS_NORMAL_MAP
            FRAG_COLOR.rgb = _texture(u_NormalSampler, getNormalUV()).rgb;
        #else
            FRAG_COLOR.rgb = vec3(0.5, 0.5, 1.0);
        #endif
    #endif

    #ifdef DEBUG_BASECOLOR
        FRAG_COLOR.rgb = LINEARtoSRGB(baseColor.rgb);
    #endif

    #ifdef DEBUG_OCCLUSION
        FRAG_COLOR.rgb = vec3(ao);
    #endif

    #ifdef DEBUG_EMISSIVE
        FRAG_COLOR.rgb = LINEARtoSRGB(emissive);
    #endif

    #ifdef DEBUG_F0
        FRAG_COLOR.rgb = vec3(f0);
    #endif

    #ifdef DEBUG_ALPHA
        FRAG_COLOR.rgb = vec3(baseColor.a);
    #endif

    FRAG_COLOR.a = 1.0;

#endif // !DEBUG_OUTPUT
}
`},hn={source:`#version VERSION

#define FEATURES

vec4 _texture(sampler2D sampler, vec2 coord)
{
#ifdef WEBGL2
    return texture(sampler, coord);
#else
    return texture2D(sampler, coord);
#endif
}

vec4 _texture(samplerCube sampler, vec3 coord)
{
#ifdef WEBGL2
    return texture(sampler, coord);
#else
    return textureCube(sampler, coord);
#endif
}
#ifdef HAS_TARGET_POSITION0
VERT_IN vec3 a_Target_Position0;
#endif

#ifdef HAS_TARGET_POSITION1
VERT_IN vec3 a_Target_Position1;
#endif

#ifdef HAS_TARGET_POSITION2
VERT_IN vec3 a_Target_Position2;
#endif

#ifdef HAS_TARGET_POSITION3
VERT_IN vec3 a_Target_Position3;
#endif

#ifdef HAS_TARGET_POSITION4
VERT_IN vec3 a_Target_Position4;
#endif

#ifdef HAS_TARGET_POSITION5
VERT_IN vec3 a_Target_Position5;
#endif

#ifdef HAS_TARGET_POSITION6
VERT_IN vec3 a_Target_Position6;
#endif

#ifdef HAS_TARGET_POSITION7
VERT_IN vec3 a_Target_Position7;
#endif

#ifdef HAS_TARGET_NORMAL0
VERT_IN vec3 a_Target_Normal0;
#endif

#ifdef HAS_TARGET_NORMAL1
VERT_IN vec3 a_Target_Normal1;
#endif

#ifdef HAS_TARGET_NORMAL2
VERT_IN vec3 a_Target_Normal2;
#endif

#ifdef HAS_TARGET_NORMAL3
VERT_IN vec3 a_Target_Normal3;
#endif

#ifdef HAS_TARGET_TANGENT0
VERT_IN vec3 a_Target_Tangent0;
#endif

#ifdef HAS_TARGET_TANGENT1
VERT_IN vec3 a_Target_Tangent1;
#endif

#ifdef HAS_TARGET_TANGENT2
VERT_IN vec3 a_Target_Tangent2;
#endif

#ifdef HAS_TARGET_TANGENT3
VERT_IN vec3 a_Target_Tangent3;
#endif

#ifdef USE_MORPHING
uniform float u_morphWeights[WEIGHT_COUNT];
#endif

#ifdef HAS_JOINT_SET1
VERT_IN vec4 a_Joint1;
#endif

#ifdef HAS_JOINT_SET2
VERT_IN vec4 a_Joint2;
#endif

#ifdef HAS_WEIGHT_SET1
VERT_IN vec4 a_Weight1;
#endif

#ifdef HAS_WEIGHT_SET2
VERT_IN vec4 a_Weight2;
#endif

#ifdef USE_SKINNING
#ifdef USE_SKINNING_TEXTURE
uniform sampler2D u_jointMatrixSampler;
uniform sampler2D u_jointNormalMatrixSampler;
#else
uniform mat4 u_jointMatrix[JOINT_COUNT];
uniform mat4 u_jointNormalMatrix[JOINT_COUNT];
#endif
#endif

// these offsets assume the texture is 4 pixels across
#define ROW0_U ((0.5 + 0.0) / 4.0)
#define ROW1_U ((0.5 + 1.0) / 4.0)
#define ROW2_U ((0.5 + 2.0) / 4.0)
#define ROW3_U ((0.5 + 3.0) / 4.0)

#ifdef USE_SKINNING
mat4 getJointMatrix(float boneNdx) {
    #ifdef USE_SKINNING_TEXTURE
    float v = (boneNdx + 0.5) / float(JOINT_COUNT);
    return mat4(
        _texture(u_jointMatrixSampler, vec2(ROW0_U, v)),
        _texture(u_jointMatrixSampler, vec2(ROW1_U, v)),
        _texture(u_jointMatrixSampler, vec2(ROW2_U, v)),
        _texture(u_jointMatrixSampler, vec2(ROW3_U, v))
    );
    #else
    return u_jointMatrix[int(boneNdx)];
    #endif
}

mat4 getJointNormalMatrix(float boneNdx) {
    #ifdef USE_SKINNING_TEXTURE
    float v = (boneNdx + 0.5) / float(JOINT_COUNT);
    return mat4(
        _texture(u_jointNormalMatrixSampler, vec2(ROW0_U, v)),
        _texture(u_jointNormalMatrixSampler, vec2(ROW1_U, v)),
        _texture(u_jointNormalMatrixSampler, vec2(ROW2_U, v)),
        _texture(u_jointNormalMatrixSampler, vec2(ROW3_U, v))
    );
    #else
    return u_jointNormalMatrix[int(boneNdx)];
    #endif
}

mat4 getSkinningMatrix()
{
    mat4 skin = mat4(0);

    #if defined(HAS_WEIGHT_SET1) && defined(HAS_JOINT_SET1)
    skin +=
        a_Weight1.x * getJointMatrix(a_Joint1.x) +
        a_Weight1.y * getJointMatrix(a_Joint1.y) +
        a_Weight1.z * getJointMatrix(a_Joint1.z) +
        a_Weight1.w * getJointMatrix(a_Joint1.w);
    #endif

    return skin;
}

mat4 getSkinningNormalMatrix()
{
    mat4 skin = mat4(0);

    #if defined(HAS_WEIGHT_SET1) && defined(HAS_JOINT_SET1)
    skin +=
        a_Weight1.x * getJointNormalMatrix(a_Joint1.x) +
        a_Weight1.y * getJointNormalMatrix(a_Joint1.y) +
        a_Weight1.z * getJointNormalMatrix(a_Joint1.z) +
        a_Weight1.w * getJointNormalMatrix(a_Joint1.w);
    #endif

    return skin;
}
#endif // !USE_SKINNING

#ifdef USE_MORPHING
vec4 getTargetPosition()
{
    vec4 pos = vec4(0);

#ifdef HAS_TARGET_POSITION0
    pos.xyz += u_morphWeights[0] * a_Target_Position0;
#endif

#ifdef HAS_TARGET_POSITION1
    pos.xyz += u_morphWeights[1] * a_Target_Position1;
#endif

#ifdef HAS_TARGET_POSITION2
    pos.xyz += u_morphWeights[2] * a_Target_Position2;
#endif

#ifdef HAS_TARGET_POSITION3
    pos.xyz += u_morphWeights[3] * a_Target_Position3;
#endif

#ifdef HAS_TARGET_POSITION4
    pos.xyz += u_morphWeights[4] * a_Target_Position4;
#endif

    return pos;
}

vec4 getTargetNormal()
{
    vec4 normal = vec4(0);

#ifdef HAS_TARGET_NORMAL0
    normal.xyz += u_morphWeights[0] * a_Target_Normal0;
#endif

#ifdef HAS_TARGET_NORMAL1
    normal.xyz += u_morphWeights[1] * a_Target_Normal1;
#endif

#ifdef HAS_TARGET_NORMAL2
    normal.xyz += u_morphWeights[2] * a_Target_Normal2;
#endif

#ifdef HAS_TARGET_NORMAL3
    normal.xyz += u_morphWeights[3] * a_Target_Normal3;
#endif

#ifdef HAS_TARGET_NORMAL4
    normal.xyz += u_morphWeights[4] * a_Target_Normal4;
#endif

    return normal;
}

vec4 getTargetTangent()
{
    vec4 tangent = vec4(0);

#ifdef HAS_TARGET_TANGENT0
    tangent.xyz += u_morphWeights[0] * a_Target_Tangent0;
#endif

#ifdef HAS_TARGET_TANGENT1
    tangent.xyz += u_morphWeights[1] * a_Target_Tangent1;
#endif

#ifdef HAS_TARGET_TANGENT2
    tangent.xyz += u_morphWeights[2] * a_Target_Tangent2;
#endif

#ifdef HAS_TARGET_TANGENT3
    tangent.xyz += u_morphWeights[3] * a_Target_Tangent3;
#endif

#ifdef HAS_TARGET_TANGENT4
    tangent.xyz += u_morphWeights[4] * a_Target_Tangent4;
#endif

    return tangent;
}

#endif // !USE_MORPHING


VERT_IN vec4 a_Position;
VERT_OUT vec3 v_Position;

#ifdef USE_INSTANCING
VERT_IN vec4 a_ModelMatrix0;
VERT_IN vec4 a_ModelMatrix1;
VERT_IN vec4 a_ModelMatrix2;
VERT_IN vec4 a_ModelMatrix3;
#endif

#ifdef USE_INSTANCING
VERT_IN vec4 a_BaseColorFactor;
VERT_OUT vec4 v_BaseColorFactor;
#endif

#ifdef USE_INSTANCING
VERT_IN vec4 a_NormalMatrix0;
VERT_IN vec4 a_NormalMatrix1;
VERT_IN vec4 a_NormalMatrix2;
VERT_IN vec4 a_NormalMatrix3;
#endif

#ifdef HAS_NORMALS
VERT_IN vec4 a_Normal;
#endif

#ifdef HAS_TANGENTS
VERT_IN vec4 a_Tangent;
#endif

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
VERT_OUT mat3 v_TBN;
#else
VERT_OUT vec3 v_Normal;
#endif
#endif

#ifdef HAS_UV_SET1
VERT_IN vec2 a_UV1;
#endif

#ifdef HAS_UV_SET2
VERT_IN vec2 a_UV2;
#endif

VERT_OUT vec2 v_UVCoord1;
VERT_OUT vec2 v_UVCoord2;

#ifdef HAS_VERTEX_COLOR_VEC3
VERT_IN vec3 a_Color;
VERT_OUT vec3 v_Color;
#endif

#ifdef HAS_VERTEX_COLOR_VEC4
VERT_IN vec4 a_Color;
VERT_OUT vec4 v_Color;
#endif

uniform mat4 u_ViewProjectionMatrix;
uniform mat4 u_ModelMatrix;
uniform mat4 u_NormalMatrix;

#ifdef USE_SHADOW_MAPPING
uniform mat4 u_LightViewProjectionMatrix;
VERT_OUT vec4 v_PositionLightSpace;
#endif

vec4 getPosition()
{
    vec4 pos = a_Position;

#ifdef USE_MORPHING
    pos += getTargetPosition();
#endif

#ifdef USE_SKINNING
    pos = getSkinningMatrix() * pos;
#endif

    return pos;
}

#ifdef HAS_NORMALS
vec4 getNormal()
{
    vec4 normal = a_Normal;

#ifdef USE_MORPHING
    normal += getTargetNormal();
#endif

#ifdef USE_SKINNING
    normal = getSkinningNormalMatrix() * normal;
#endif

    return normalize(normal);
}
#endif

#ifdef HAS_TANGENTS
vec4 getTangent()
{
    vec4 tangent = a_Tangent;

#ifdef USE_MORPHING
    tangent += getTargetTangent();
#endif

#ifdef USE_SKINNING
    tangent = getSkinningMatrix() * tangent;
#endif

    return normalize(tangent);
}
#endif

void main()
{
    mat4 modelMatrix = u_ModelMatrix;
    #ifdef USE_INSTANCING
        modelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);
    #endif
    vec4 pos = modelMatrix * getPosition();
    v_Position = vec3(pos.xyz) / pos.w;

    mat4 normalMatrix = u_NormalMatrix;
    #ifdef USE_INSTANCING
        normalMatrix = mat4(a_NormalMatrix0, a_NormalMatrix1, a_NormalMatrix2, a_NormalMatrix3);
    #endif

    #ifdef HAS_NORMALS
    #ifdef HAS_TANGENTS
    vec4 tangent = getTangent();
    vec3 normalW = normalize(vec3(normalMatrix * vec4(getNormal().xyz, 0.0)));
    vec3 tangentW = normalize(vec3(modelMatrix * vec4(tangent.xyz, 0.0)));
    vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
    v_TBN = mat3(tangentW, bitangentW, normalW);
    #else // !HAS_TANGENTS
    v_Normal = normalize(vec3(normalMatrix * vec4(getNormal().xyz, 0.0)));
    #endif
    #endif // !HAS_NORMALS

    v_UVCoord1 = vec2(0.0, 0.0);
    v_UVCoord2 = vec2(0.0, 0.0);

    #ifdef HAS_UV_SET1
    v_UVCoord1 = a_UV1;
    #endif

    #ifdef HAS_UV_SET2
    v_UVCoord2 = a_UV2;
    #endif

    #if defined(HAS_VERTEX_COLOR_VEC3) || defined(HAS_VERTEX_COLOR_VEC4)
    v_Color = a_Color;
    #endif

    #ifdef USE_SHADOW_MAPPING
    v_PositionLightSpace = u_LightViewProjectionMatrix * pos;
    #endif

    #ifdef USE_INSTANCING
    v_BaseColorFactor = a_BaseColorFactor;
    #endif

    gl_Position = u_ViewProjectionMatrix * pos;
}
`};class Ze extends _e{constructor(){super(...arguments),this._instancing=new on}static build(e,t){let n=p.Program.from(se.build(hn.source,t,e),se.build(ln.source,t,e));return new Ze(n)}get name(){return"standard-shader"}createShaderGeometry(e,t){let n=super.createShaderGeometry(e,t);if(t&&this._instancing.addGeometryAttributes(n),e.targets)for(let i=0;i<e.targets.length;i++){let a=e.targets[i].positions;a&&n.addAttribute(`a_Target_Position${i}`,new p.Buffer(a.buffer),3,!1,a.componentType,a.stride);let s=e.targets[i].normals;s&&n.addAttribute(`a_Target_Normal${i}`,new p.Buffer(s.buffer),3,!1,s.componentType,s.stride);let o=e.targets[i].tangents;o&&n.addAttribute(`a_Target_Tangent${i}`,new p.Buffer(o.buffer),3,!1,o.componentType,o.stride)}return e.uvs&&e.uvs[1]&&n.addAttribute("a_UV2",new p.Buffer(e.uvs[1].buffer),2,!1,e.uvs[1].componentType,e.uvs[1].stride),e.joints&&n.addAttribute("a_Joint1",new p.Buffer(e.joints.buffer),4,!1,e.joints.componentType,e.joints.stride),e.weights&&n.addAttribute("a_Weight1",new p.Buffer(e.weights.buffer),4,!1,e.weights.componentType,e.weights.stride),n}render(e,t,n,i){if(e.instances.length>0){const a=e.instances.filter(s=>s.worldVisible&&s.renderable);if(a.length===0)return;this._instancing.updateBuffers(a)}super.render(e,t,n,i)}}var Te=(r=>(r.opaque="opaque",r.transparent="transparent",r))(Te||{});class Ee{constructor(){this._renderSortType=Te.opaque,this.state=Object.assign(new p.State,{culling:!0,clockwiseFrontFace:!1,depthTest:!0}),this.drawMode=R.DRAW_MODES.TRIANGLES,this.renderSortType=Te.opaque}get depthMask(){return this.state.depthMask}set depthMask(e){this.state.depthMask=e}get doubleSided(){return!this.state.culling}set doubleSided(e){this.state.culling=!e}get blendMode(){return this.state.blendMode}set blendMode(e){this.state.blendMode=e}createShader(e,t){}updateUniforms(e,t){}destroy(){}get isInstancingSupported(){return!1}createInstance(){}render(e,t){!this._shader&&(this._shader=this.createShader(e,t),!this._shader)||(this.updateUniforms&&this.updateUniforms(e,this._shader),this._shader.render(e,t,this.state,this.drawMode))}static from(e,t,n){return Object.assign(new Ee,{updateUniforms:n||(()=>{}),_shader:new _e(p.Program.from(e,t))})}}class oe{constructor(e,t){this.renderer=e,this.lights=[],this.renderer.on("prerender",()=>{for(let n of this.lights)n.parent||n.transform.updateTransform()}),oe.main||(oe.main=this),this.imageBasedLighting=t}destroy(){}get valid(){return!this.imageBasedLighting||this.imageBasedLighting.valid}}C.installRendererPlugin("lighting",oe);class un{enableJointMatrixTextures(e){this._jointMatrixTexture||(this._jointMatrixTexture=new Ae(e)),this._jointNormalTexture||(this._jointNormalTexture=new Ae(e))}destroy(){var e,t;(e=this._jointNormalTexture)==null||e.destroy(!0),(t=this._jointMatrixTexture)==null||t.destroy(!0)}update(e,t){!e.skin||(this._jointMatrixTexture?(this._jointMatrixTexture.updateBuffer(e.skin.jointMatrices),t.uniforms.u_jointMatrixSampler=this._jointMatrixTexture):t.uniforms.u_jointMatrix=e.skin.jointMatrices,this._jointNormalTexture?(this._jointNormalTexture.updateBuffer(e.skin.jointNormalMatrices),t.uniforms.u_jointNormalMatrixSampler=this._jointNormalTexture):t.uniforms.u_jointNormalMatrix=e.skin.jointNormalMatrices)}}class k{constructor(e=0,t=0,n=0,i=1){this._array4=new Float32Array([e,t,n,i]),this._array3=this._array4.subarray(0,3)}static fromBytes(e=0,t=0,n=0,i=255){return new k(e/255,t/255,n/255,i/255)}static fromHex(e){return typeof e=="string"&&(e=parseInt(e.replace(/[^0-9A-F]/gi,""),16)),k.fromBytes(e>>16&255,e>>8&255,e&255)}get rgb(){return this._array3}get rgba(){return this._array4}get r(){return this._array4[0]}set r(e){this._array4[0]=e}get g(){return this._array4[1]}set g(e){this._array4[1]=e}get b(){return this._array4[2]}set b(e){this._array4[2]=e}get a(){return this._array4[3]}set a(e){this._array4[3]=e}static from(e){return new k(...e)}}class Et{constructor(e){this.baseColor=new k(...e.baseColor.rgba)}}class bt{constructor(){this.alphaCutoff=.5,this.alphaMode="OPAQUE",this.doubleSided=!1,this.roughness=1,this.metallic=1,this.emissiveFactor=[0,0,0],this.baseColor=[1,1,1,1],this.unlit=!1}}class Mt{static multiply(e,t,n=new Float32Array(9)){return ar(n,e,t)}}class ie{constructor(){this._rotation=0,this._array=new Float32Array(9),this._dirty=!0,this._translation=new Float32Array([1,0,0,0,1,0,0,0,1]),this._scaling=new Float32Array([1,0,0,0,1,0,0,0,1]),this._rotate=new Float32Array([Math.cos(0),-Math.sin(0),0,Math.sin(0),Math.cos(0),0,0,0,1]),this.offset=new U.ObservablePoint(()=>{this._translation.set([1,0,0,0,1,0,this.offset.x,this.offset.y,1]),this._dirty=!0},void 0),this.scale=new U.ObservablePoint(()=>{this._scaling.set([this.scale.x,0,0,0,this.scale.y,0,0,0,1]),this._dirty=!0},void 0,1,1)}get rotation(){return this._rotation}set rotation(e){this._rotation=e,this._rotate.set([Math.cos(e),-Math.sin(e),0,Math.sin(e),Math.cos(e),0,0,0,1]),this._dirty=!0}get array(){return this._dirty&&(Mt.multiply(Mt.multiply(this._translation,this._rotate,this._array),this._scaling,this._array),this._dirty=!1),this._array}static fromTexture(e){const t=new ie;if(!e.frame||e.noFrame)return t;let{x:n,y:i,width:a,height:s}=e.frame;return e.rotate===0&&(t.offset.set(n/e.baseTexture.width,i/e.baseTexture.height),t.scale.set(a/e.baseTexture.width,s/e.baseTexture.height)),e.rotate===2&&(n=e.frame.x+e.frame.width,t.offset.set(n/e.baseTexture.width,i/e.baseTexture.height),t.scale.set(s/e.baseTexture.height,a/e.baseTexture.width),t.rotation=-90*U.DEG_TO_RAD),t}}class xe extends p.Texture{constructor(e,t){super(e),this.uvSet=t}}class Rt extends xe{constructor(e,t,n){super(e,n),this.scale=t,this.uvSet=n}}class It extends xe{constructor(e,t,n){super(e,n),this.strength=t,this.uvSet=n}}class Ct{create(e){let t=new le;if(!(e instanceof bt))return t;switch(t.baseColor=k.from(e.baseColor),e.baseColorTexture&&(t.baseColorTexture=new xe(e.baseColorTexture.baseTexture,e.baseColorTexture.texCoord),t.baseColorTexture.transform=this.createTextureTransform(e.baseColorTexture)),t.metallic=e.metallic,t.roughness=e.roughness,e.metallicRoughnessTexture&&(t.metallicRoughnessTexture=new xe(e.metallicRoughnessTexture.baseTexture,e.metallicRoughnessTexture.texCoord),t.metallicRoughnessTexture.transform=this.createTextureTransform(e.metallicRoughnessTexture)),t.emissive=k.from(e.emissiveFactor),e.emissiveTexture&&(t.emissiveTexture=new xe(e.emissiveTexture.baseTexture,e.emissiveTexture.texCoord),t.emissiveTexture.transform=this.createTextureTransform(e.emissiveTexture)),e.alphaMode){case"BLEND":{t.alphaMode=re.blend,t.renderSortType=Te.transparent;break}case"MASK":{t.alphaMode=re.mask;break}case"OPAQUE":{t.alphaMode=re.blend;break}}return t.unlit=e.unlit,t.doubleSided=e.doubleSided,t.alphaCutoff=e.alphaCutoff,e.normalTexture&&(t.normalTexture=new Rt(e.normalTexture.baseTexture,e.normalTexture.scale,e.normalTexture.texCoord),t.normalTexture.transform=this.createTextureTransform(e.normalTexture)),e.occlusionTexture&&(t.occlusionTexture=new It(e.occlusionTexture.baseTexture,e.occlusionTexture.strength,e.occlusionTexture.texCoord),t.occlusionTexture.transform=this.createTextureTransform(e.occlusionTexture)),t}createTextureTransform(e){if(e.transform){const t=new ie;return e.transform.offset&&(t.offset.x=e.transform.offset[0],t.offset.y=e.transform.offset[1]),e.transform.rotation!==void 0&&(t.rotation=e.transform.rotation),e.transform.scale&&(t.scale.x=e.transform.scale[0],t.scale.y=e.transform.scale[1]),t}}}var cn="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAMAAAD04JH5AAADAFBMVEX/AACvAwC4BgC1BQD7AAD3AQDzAQD+AAD9AAD8AQDpAQC/CACxAwD5BgDACwCtAwDxAQC9CADDEQCrAwC7BwC4AQDfAQB+AADvAQD1AQD7AwB7AABrAADHAQDCDgDiAQCyBQCRAQD5AAC1AQDYAQDNAQCpAQCUAQCeAQB0AABhAAD3BwCnAQDCBwCMAACOAAD6BABvAADFAgDsAQD4AACIAADEDADKAQDnAQCfAQCoAwDuEADqFACAAACFAACKAADzCwCCAAC/AQCbAgDKDQDwDgC9AQDBAgCiAAC7AQCkAADlAQD0CACzAQDjGwBoAADEFgB4AAD2CADGEQDGDADQAQDbAQDGCADSAQDNCwDWAQDdAQDUAQBlAAB2AADJCADBGgCVAgDOEADtAQBxAADSDADBFgCZAADnGADXDADcIgDKEgDDAQBcAADQLQCkAwDSEADPCADfHgClAgDXBwDTCADkDACYAAC9IACxLgCiAwCZAgDIFgDINgDdDADxCgDuCACSAQDnEADqCgCPAQBYAAC+HADYJgDLMACWAADOFgDbEQCtMwDSGwCGAADLBgC4JwDbGADaDADBIACoVQDRIQCgAgCxTQDHGwDVKQC6IwDCPACRbADGIQDMGwBUAADgEQDgBwDXEgDkFQDkBgCHdgDnCQDSFQC1KgDWFwDgFwDgDACaRwDCJwCcAADLKAC4LwC2RwDELwCYZADLIACkPQDcBgC9KACFXgDrEAB/ZQCoOgDGKAC+LgDYHACpTwC6QwCWTQB5bQCiWwCcAgCfQgBxdACMVgCzNAB9fwCeYADXIQC4NwC+NgCxOgCHbQCRUQDDNwCrOQDRJwCnRQCYWQCuQQBnfQC+QACNZABziwBskAAY4QCXAgB4hQBghgBllwC1QACtSACfTgBfngCPXABYpQChSAC7PAB/dwCeVABTkQBKnABRrABBuwA4wwBcjgBKtAByfAAxywBApQA3sAAo1QBshgAK8QAY0QBXmgAkxgBPpAAqugBFrgA1uwB98tmWAAAOvklEQVR4nO3Ye1jW5RnA8d+Wtmmews2yJTlXrVWUmUNLt5xSVrpygqJZQShMwqWYOHSWhvMwkSESRRaej5hT8ZiJpCvDI5annGYecmpaOWdhHnff93O6n+f3exFc17yubTfG1V9+P8/9/F54X73Tp/fs+fqfX37xj8///um+3X/bu27GjDfeWLT+ry+//OqrC9/56PXXX3hh9HPPvTZq1LPP9u//2GO9e7du3bpVq1YPPtimTZuOHTvfAVO7dtOmN9xwQ40aNb6P8z01XqXm/4DTp09//b+9gT2n91zZDezZc6U3sOcKb+CbKw745hvo/7cALkcAgLNwA198fsUAZ8+epUfg8081YNF/EnD2/NmzX14UN3AZG+j8LQDOn7948YsLdAO7964jwHof4DUOeKuSgEoJCPDVhQvn5CPgXsEHLqD3twy4eP4rGAM4OqNMAEqqBGgaCKiM4KLsnzvz7wIucwUIOHXqFAD2nagS4EEGCHkHlSBcwPypc8fPnDmxu7xcAtZXFtAxEFClS7iA/ePHj585se+T8r0nsY+vQgQsrAqA/zC2VnApwgXKHz9z7MSJ8vKT66oM6GwDggQVE85h/tgx6H+iALvoVVgJQBsNqOAOLiUAwLHj1P+k/OTJo0fLynYtWrQdAQeCAI+FBFyu4MyZYzjQ37lTAbYDoAQ28M47RwAw2g94CwFD1UMQBHAFoQ0EOCH7a9dAf9eu7ds/gwUcsAGjLEArDehMAHEHFQpCIPadwDr2d0IfF4B9Adh/5MgmDdggANM4IPAOKhIEMPbp/tq1a9esWbFr1yEEHATA/v1HPpKArQLQXwBaM4C6g6oILM1umRf9MgUoEYAjHPCsAfCHwFqBJagMwSsvL9+p+2tWLN91CAEHAbBDAIoAsHXraxsUYFqGfQfOCmzBpQme6K8V+1+xAvqH8AYObyPAJgLMl4DC/oUIyNCAoXwFwYJLGby9J+HhXyvPv2L58kOHtsACDpZs2wGAjQgoQsDWDRtWwQYKC6dN660BQ4cGrUAIOKEihLdO9CmP/fcPbVl9EBagAEVFRfMBkEeAQgRMQwAKhqKAraBJU74DhxBK4a07KvKiv/z997cA4DABNm+0AatyJECuYJgEKEETJahWrUYIQ8DviaNH1xwVedO3ASsJkAeA/oV0BxkZGbiCYQgY2rGjuITqtWs3byIJ1aoZQqCBabwZKi/6CFgt+wgoFhvII0COWIEGGAEAqtdurgRNqlmEChFeWVkZy8u+BhQX0wbmWwApGNbKABre0bB69eYkAEITIbAMoRQIKMO6Of+bb7733ra3P9y8uXTjgmIQrFzpBwzPGP7WMLaChjDVDQG/BRkCJN4b8MtH1k1/yRIDmAeAxQDIQgAIJtMGADA8tEBMtWqhERri7cI5dEjkZf+9JW8DoLR0AQDm+QCTBQBGCOoRoaEhMINBhHJ4i/Bnn8xTXy6AAxYbQM5kAAy0BTBXw4Qg2Agfw4O3PyDYIvK6//aHY0s5YPHEvKw5c1YJwOSBAwcKAAmuB0A9LQgkuAhG8dZvhxF1kRcLGDsW+wuWLQNAAQDysrJAAIBMIcjImKkFQ68fWq/j1RaBDC4iEEKA1dtlXpyfFjB2EADGIaAAARMJMDUnM1OtYOZMtoJ6MA4hpMF2eJ/hrD64+k19fNEfO2jQbAUAwcSJCJgzNVMLZhoBGhwCM4RU0CDgIIy/X0p9CZgoATlCMHeuLbgepp5LEAaFCKXwXj5Ygj/7Dx+WeeiPpfMPmj2bALkCkJU1a9asOVMVgAvu9RG0QSK0ws/wSkpKDsu+yBNA9MdNWJaeC4D8fNjAmFlZCEDBi3O1gAj39uw5rKcmuAaFMAoOAcDhkm0wS7aZvOqPW5aePk8DxsAKJEAKpmsBEHoSga+BIwzDcjRv7h04cIDnqY8PIC1gQjpuIB8BYyyAEExHQc2ZNYfXvNclaIOFYAwlQcCBHdu2URx+/snzE2CCAOQCYIjcQD8QjM8cLwXTpxNhZs2aKDAEaTAIR8Eh3sIDO2g+xBlr+uNEHwDxCBgyhlbQDwTJ48cLwZQpStByuCHYBoYIYMB4C/djfbPKD1LHFxcAgHgBSEFAPwAkJyvBlCmS0KFlSyS4Bo2wFI7D2w+zGWdsqdtHwMj43PhO0EdAQgIA+iVrwZQpFqGmJAiDD+EyJEQD4HdPqcrLPgBGjoyPj+/UCQEpCQkkSHQE02k6KEKAwVK4DO/Ikf0bN5ZSvlTl9QNAfQB0QoAUJCrB0qVLzQ46dCACM0iEUVgMDQHARhwSLJhtHV8vQAJIkJjIBZJwUwiDQjCF65CABTSiLvoT0kdCHwBJkDeAxEQlGCAE0nCTFDCDi7AZyuFtwllAgtnjFjh57Cc5G0BDWlryABwh6IEAmg7GIBFKwRi2w/sA+8ViAzovnj8EJBEgOjoaAVHqDkCQNmDAeC3o0aBBkEEhtIIzeirAB5uKN8Gb3+JlOLpu+hKAhKjuOImpBEgbwJeAhgYNLINEaIVhcAcAioqpD4IJSEhPF4+f6gMgDPPRKVFRJEhNlQJJ6Np1aVcUEEEaNEIpDIM5UOLBR6+i4iK5gGWyrvpiA2FhtIGoaFcgAANuvrkrInr0sPbAEEEM5fBeQME8GpkXdXX+pKQwBaDpLgmpaS4Bpoe7CEuhGRzijSZA0Tx46wNf6bmqD6cfqfpCEBMVowipqZrw5JNCoAwMYRQWgzlaImD0ShzcQK6Yker1Z/oIiIkhQTYTkOFJmCeeGPDEzS7Cp3AcAuKNnj9aAApyhSCeJkn35QoiY3DioqLi4rKzu2cLQrfULt26pXUTBhhmsBUWw3J48Nl7PgDgnWeBvy/rYeFhkTAkoMmmIUOXLmDoRgaDcBWKYTsI4j1HggI58fG5/PyqHx4eKQWxcUEEMrgIo1AM7WAQbyv0F8+nem5BfH7g+RUgMiYWhgGyb7lFAAIQUsEY2mEgDQAAAvjotbgA3/zmF+R3gt9++vxJ4bB904+MlWMbYCyEUIRkMAhIALB1MU1BPgri8/F3j9p+nSTR9wli+UU4CEshGcphQ1Di4T+ACUE+Tic58vEPNxPpGgSiRYsW2dktblHTJZihHBqiJd7WPCGYKABKIG6/TlIditP3iIjICJjY2AgJaNSoURz810JNgEIytENDtMTLy8P+RBx895vP+2EyXocmIjxCT7NmzWLhT2xss0Y0LfwKy6Egfok3Ko+GBPDecwjrh1t9EKiJlQY9jVwGdwRCtMTbkLdB5qkP7770+cOsvEWQ06dPAIM7QkI0xduwAf/1JcsIojtFq3yS069zjRxot2/fnr6179PHZgQ6LIhFAQDk87LGjNEAGHMBTllPe3f6WJBG1rSowOKtWoWCiVn42S8lRfSjzQOg+9daQ4i2OMESzWlUEaWFAKzCKxCAISkKEM4X4NTlPKSmbVsfpY89AVtRGASskn3YgALwPo/+gM0j1z7ykG/asgm09HHuCAFz5mTNmiUBKSkuILgO/aCpqqZPMy8HAXMMgG2g6v2KOG2DOV5OjgCAIIEAQAiL9PV1+Lt8fhhiqgACQI4AzEpIUBuAXzl2P6BdUb/SJHB4hQYgriAK+5G8789fJeYnlZlLoDiANhAVHRPQ97Vxfl3ZqciFgBwCwOfOlAT4+BWjAeb4/vhVVzWmv7tx48Y8VUtO5WUEmDp1zqx++MlX98PVj5+gfGM1svadKkwtNmTwCguhP3Vqv34JQIhiC3D6dtzXrRtybEBd+aUHATkCADcAnz8V4Bp1Ab48a/NQ/VBzq/1Vt775ql+/LgIy3Q3wBZi8rNttq1T1qX8rADIlICGKAGwBvM/PbrXZX3e/nDsrnkfpjxxvWmFmjtpAlAbQr1+nz+tW3G0+b+bRS443bbLeALsBp6/zfOsmjak7Te/hwLlPfuEfNgTI1IAYC8D7Tp7i+rR9+wZkX1Fznzu34cj/B8BkAUhM6C5fhE6/sezrPB1dxfv27Tt48GAryiowf6lg2rVrpwGJGhBBAKtv57Eu44NpXnnlYRW+ze62k/PbkCMByQDorgF6AVaf8verel9ZV2dmXTf5ezEfq/kTHwFITsYFdKfXAFuA7rt5FtdtWeZRlntGzE/VvKTGBsQhIIIWENCnZ17nRR3K74q2KausSb7E5sdq/kjDAVEAiBU3IBeg+ip/P+bl4eno78KoY4u0DPMqy8m5W85dd92FgBcJQDcA/Yg61gJ438qr+h9UW6RNmVdVTs8DarwMAIxXgFi2AKtv52Ud4jAyTm23zLM6+cDP+ViAOPjszxbg9k2ezi7qIq7OrdIm7Eb/bOaXOA5APIJiAVZfHV/m6fCmzto6bYWtJs6v1HgZAzUgLk7dgLwA3rfydHiqO3GTtsJu9RdmADCXAKnyBtgC3D48eioPh6ezm7qImzYvO9nr+AQC1AU4fXr0VF5unuombtqs7O/+yIwNiIyANwJsAbIv13+buHuZ99V13LSdsMn+Rs3TEpAGAHoEQvX18Vle1dXRVdzfdsNPi/kZjA2I4AC8ANaX2w/KO3HetsumK6dXLw2AF4F4BCrq06On825dxe12ULmXmHtgHIBeAF2A24cXXnDe1EO07fI9em68UQFSu2drAFuA7os89WXeqeujO20rzcJqLIC5AbmA55+nPj++P8/PruPs3Fb6RjaP4xgAPoNqAbVUv29AXyyf8vrwvjo7tz/9uJqnnnrKG64B4gbEAswFqP4zKn+3nXfr+uSBbVamuf12CUjkAL2Avub+nzHHD8izuj65G/elxTgbEDeACxAPQIi+P8/q5ujB7dutEYC0tNTsuKAFsH6IvDy8r27HA9q/EyMBiRyAL4FL9HneHN49Oo8HtGFGjCBAMgPQDcAC6ALg5w/vh8zze684ztJiFKA7/RTAR4BugBaALwDTt4+v887hWd2N+9ojRkyaNIkAA+gZjIiQN0ALUBfg9HX+OjsfWPfHrTYNB4gbkAugC4D+x9QX128f38mHrPvik/gogH4EGtfSC4ALkH08v1y/yYu77+XmA+vBcZx/AeDdATn/vA1ZAAAAAElFTkSuQmCC";class $e{get diffuse(){return this._diffuse}get specular(){return this._specular}constructor(e,t){this._diffuse=e,this._specular=t}get valid(){return this._diffuse.valid&&this._specular.valid&&(!this.lookupBrdf||this.lookupBrdf.valid)}}$e.defaultLookupBrdf=p.Texture.from(cn,{mipmap:R.MIPMAP_MODES.OFF});const et={},Nt=r=>r?r.lights.length+(r.imageBasedLighting?.5:0):0;class le extends Ee{constructor(){super(...arguments),this._lightingEnvironmentConfigId=0,this._unlit=!1,this._alphaMode=re.blend,this._baseColorFactor=new Float32Array(4),this._instancingEnabled=!1,this._skinUniforms=new un,this.roughness=1,this.metallic=1,this.baseColor=new k(1,1,1,1),this.alphaCutoff=.5,this.emissive=new k(0,0,0),this.exposure=1}get baseColorTexture(){return this._baseColorTexture}set baseColorTexture(e){e!==this._baseColorTexture&&(this.invalidateShader(),!(e!=null&&e.transform)&&(e==null?void 0:e.frame)&&!(e!=null&&e.noFrame)&&(e.transform=ie.fromTexture(e)),this._baseColorTexture=e)}get metallicRoughnessTexture(){return this._metallicRoughnessTexture}set metallicRoughnessTexture(e){e!==this._metallicRoughnessTexture&&(this.invalidateShader(),!(e!=null&&e.transform)&&(e==null?void 0:e.frame)&&!(e!=null&&e.noFrame)&&(e.transform=ie.fromTexture(e)),this._metallicRoughnessTexture=e)}get normalTexture(){return this._normalTexture}set normalTexture(e){e!==this._normalTexture&&(this.invalidateShader(),!(e!=null&&e.transform)&&(e==null?void 0:e.frame)&&!(e!=null&&e.noFrame)&&(e.transform=ie.fromTexture(e)),this._normalTexture=e)}get occlusionTexture(){return this._occlusionTexture}set occlusionTexture(e){e!==this._occlusionTexture&&(this.invalidateShader(),!(e!=null&&e.transform)&&(e==null?void 0:e.frame)&&!(e!=null&&e.noFrame)&&(e.transform=ie.fromTexture(e)),this._occlusionTexture=e)}get emissiveTexture(){return this._emissiveTexture}set emissiveTexture(e){e!==this._emissiveTexture&&(this.invalidateShader(),!(e!=null&&e.transform)&&(e==null?void 0:e.frame)&&!(e!=null&&e.noFrame)&&(e.transform=ie.fromTexture(e)),this._emissiveTexture=e)}get alphaMode(){return this._alphaMode}set alphaMode(e){this._alphaMode!==e&&(this._alphaMode=e,this.invalidateShader())}get shadowCastingLight(){return this._shadowCastingLight}set shadowCastingLight(e){e!==this._shadowCastingLight&&(this.invalidateShader(),this._shadowCastingLight=e)}get debugMode(){return this._debugMode}set debugMode(e){this._debugMode!==e&&(this.invalidateShader(),this._debugMode=e)}get lightingEnvironment(){return this._lightingEnvironment}set lightingEnvironment(e){e!==this._lightingEnvironment&&(this.invalidateShader(),this._lightingEnvironmentConfigId=Nt(e),this._lightingEnvironment=e)}get unlit(){return this._unlit}set unlit(e){this._unlit!==e&&(this._unlit=e,this.invalidateShader())}destroy(){var e,t,n,i,a;(e=this._baseColorTexture)==null||e.destroy(),(t=this._normalTexture)==null||t.destroy(),(n=this._emissiveTexture)==null||n.destroy(),(i=this._occlusionTexture)==null||i.destroy(),(a=this._metallicRoughnessTexture)==null||a.destroy(),this._skinUniforms.destroy()}invalidateShader(){this._shader=void 0}static create(e){return new Ct().create(e)}render(e,t){!this._instancingEnabled&&e.instances.length>0&&(this.invalidateShader(),this._instancingEnabled=!0),this._instancingEnabled&&e.instances.length===0&&(this.invalidateShader(),this._instancingEnabled=!1);let n=this.lightingEnvironment||oe.main,i=Nt(n);i!==this._lightingEnvironmentConfigId&&(this.invalidateShader(),this._lightingEnvironmentConfigId=i),super.render(e,t)}get isInstancingSupported(){return!0}createInstance(){return new Et(this)}createShader(e,t){if(t.context.webGLVersion===1){let s=["EXT_shader_texture_lod","OES_standard_derivatives"];for(let o of s)t.gl.getExtension(o)}let n=this.lightingEnvironment||oe.main,i=Fe.build(t,e,e.geometry,this,n);if(!i)return;e.skin&&Fe.hasSkinningTextureFeature(i)&&this._skinUniforms.enableJointMatrixTextures(e.skin.joints.length);let a=i.join(",");return et[a]||(et[a]=Ze.build(t,i)),et[a]}updateUniforms(e,t){var n,i,a,s,o;for(let d=0;d<3;d++)this._baseColorFactor[d]=this.baseColor.rgba[d];this._baseColorFactor[3]=this.baseColor.a*e.worldAlpha;let l=this.camera||H.main;e.skin&&this._skinUniforms.update(e,t),t.uniforms.u_Camera=l.worldTransform.position.array,t.uniforms.u_ViewProjectionMatrix=l.viewProjection.array,t.uniforms.u_Exposure=this.exposure,t.uniforms.u_MetallicFactor=this.metallic,t.uniforms.u_RoughnessFactor=this.roughness,t.uniforms.u_BaseColorFactor=this._baseColorFactor,t.uniforms.u_ModelMatrix=e.worldTransform.array,t.uniforms.u_NormalMatrix=e.transform.normalTransform.array,this._alphaMode===re.mask&&(t.uniforms.u_AlphaCutoff=this.alphaCutoff),e.targetWeights&&(t.uniforms.u_morphWeights=e.targetWeights),(n=this.baseColorTexture)!=null&&n.valid&&(t.uniforms.u_BaseColorSampler=this.baseColorTexture,t.uniforms.u_BaseColorUVSet=this.baseColorTexture.uvSet||0,this.baseColorTexture.transform&&(t.uniforms.u_BaseColorUVTransform=this.baseColorTexture.transform.array));let h=this.lightingEnvironment||oe.main;for(let d=0;d<h.lights.length;d++){let c=h.lights[d],f=0;switch(c.type){case W.point:f=1;break;case W.directional:f=0;break;case W.spot:f=2;break}t.uniforms[`u_Lights[${d}].type`]=f,t.uniforms[`u_Lights[${d}].position`]=c.worldTransform.position.array,t.uniforms[`u_Lights[${d}].direction`]=c.worldTransform.forward.array,t.uniforms[`u_Lights[${d}].range`]=c.range,t.uniforms[`u_Lights[${d}].color`]=c.color.rgb,t.uniforms[`u_Lights[${d}].intensity`]=c.intensity,t.uniforms[`u_Lights[${d}].innerConeCos`]=Math.cos(c.innerConeAngle*U.DEG_TO_RAD),t.uniforms[`u_Lights[${d}].outerConeCos`]=Math.cos(c.outerConeAngle*U.DEG_TO_RAD)}this._shadowCastingLight&&(t.uniforms.u_ShadowSampler=this._shadowCastingLight.shadowTexture,t.uniforms.u_LightViewProjectionMatrix=this._shadowCastingLight.lightViewProjection,t.uniforms.u_ShadowLightIndex=h.lights.indexOf(this._shadowCastingLight.light));let u=h.imageBasedLighting;u!=null&&u.valid&&(t.uniforms.u_DiffuseEnvSampler=u.diffuse,t.uniforms.u_SpecularEnvSampler=u.specular,t.uniforms.u_brdfLUT=u.lookupBrdf||$e.defaultLookupBrdf,t.uniforms.u_MipCount=u.specular.levels-1),(i=this.emissiveTexture)!=null&&i.valid&&(t.uniforms.u_EmissiveSampler=this.emissiveTexture,t.uniforms.u_EmissiveUVSet=this.emissiveTexture.uvSet||0,t.uniforms.u_EmissiveFactor=this.emissive.rgb,this.emissiveTexture.transform&&(t.uniforms.u_EmissiveUVTransform=this.emissiveTexture.transform.array)),(a=this.normalTexture)!=null&&a.valid&&(t.uniforms.u_NormalSampler=this.normalTexture,t.uniforms.u_NormalScale=this.normalTexture.scale||1,t.uniforms.u_NormalUVSet=this.normalTexture.uvSet||0,this.normalTexture.transform&&(t.uniforms.u_NormalUVTransform=this.normalTexture.transform.array)),(s=this.metallicRoughnessTexture)!=null&&s.valid&&(t.uniforms.u_MetallicRoughnessSampler=this.metallicRoughnessTexture,t.uniforms.u_MetallicRoughnessUVSet=this.metallicRoughnessTexture.uvSet||0,this.metallicRoughnessTexture.transform&&(t.uniforms.u_MetallicRoughnessUVTransform=this.metallicRoughnessTexture.transform.array)),(o=this.occlusionTexture)!=null&&o.valid&&(t.uniforms.u_OcclusionSampler=this.occlusionTexture,t.uniforms.u_OcclusionStrength=this.occlusionTexture.strength||1,t.uniforms.u_OcclusionUVSet=this.occlusionTexture.uvSet||0,this.occlusionTexture.transform&&(t.uniforms.u_OcclusionUVTransform=this.occlusionTexture.transform.array))}}class be{constructor(){this._onChanged=()=>{this._center.set((this._min.x+this._max.x)/2,(this._min.y+this._max.y)/2,(this._min.z+this._max.z)/2),this._extents.set(Math.abs(this._max.x-this._center.x),Math.abs(this._max.y-this._center.y),Math.abs(this._max.z-this._center.z)),this._size.set(this._extents.x*2,this._extents.y*2,this._extents.z*2)},this._min=new y(0,0,0,this._onChanged,this),this._max=new y(0,0,0,this._onChanged,this),this._center=new y(0,0,0,()=>{},this),this._size=new y(0,0,0,()=>{},this),this._extents=new y(0,0,0,()=>{},this)}get min(){return this._min}set min(e){this._min.copyFrom(e)}get max(){return this._max}set max(e){this._max.copyFrom(e)}get center(){return this._center}get size(){return this._size}get extents(){return this._extents}static from(e){let t=new be;return t.min.setFrom(e.min),t.max.setFrom(e.max),t}encapsulate(e){this._min.x=Math.min(this._min.x,e.x),this._min.y=Math.min(this._min.y,e.y),this._min.z=Math.min(this._min.z,e.z),this._max.x=Math.max(this._max.x,e.x),this._max.y=Math.max(this._max.y,e.y),this._max.z=Math.max(this._max.z,e.z)}}var tt;(r=>{function e(t={}){const{radius:n=1,segments:i=32,rings:a=16}=t,s=[],o=[],l=[],h=[],u=[];let d=0;for(let c=0;c<=a;c++){const f=[],m=c/a;let _=0;c==0?_=.5/i:c==a&&(_=-.5/i);for(let g=0;g<=i;g++){const T=g/i;let M=-n*Math.cos(T*Math.PI*2)*Math.sin(m*Math.PI),S=n*Math.cos(m*Math.PI),w=n*Math.sin(T*Math.PI*2)*Math.sin(m*Math.PI),E=x.fromValues(M,S,w);l.push(M,S,w),u.push(...x.normalize(E)),h.push(T+_,1-m),f.push(d++)}s.push(f)}for(let c=0;c<a;c++)for(let f=0;f<i;f++){const m=s[c][f+1],_=s[c][f],g=s[c+1][f],T=s[c+1][f+1];c!==0&&o.push(m,_,T),c!==a-1&&o.push(_,g,T)}return Object.assign(new pe,{normals:{buffer:new Float32Array(u)},uvs:[{buffer:new Float32Array(h)}],indices:{buffer:new Uint16Array(o)},positions:{buffer:new Float32Array(l)}})}r.create=e})(tt||(tt={}));class X extends V{constructor(e,t){if(super(),this.geometry=e,this.material=t,this.pluginName="pipeline",this.enabledRenderPasses={material:{}},this.renderSortOrder=0,this._instances=[],!e)throw new Error("PIXI3D: Geometry is required when creating a mesh.")}get instances(){return this._instances}createInstance(){var e;if(this.material&&!this.material.isInstancingSupported)throw new Error("PIXI3D: Can't create instance of mesh, material does not support instancing.");return this._instances[this._instances.push(new sn(this,(e=this.material)==null?void 0:e.createInstance()))-1]}removeInstance(e){const t=this._instances.indexOf(e);t>=0&&this._instances.splice(t,1)}enableRenderPass(e,t){this.enabledRenderPasses[e]||(this.enabledRenderPasses[e]=t||{})}disableRenderPass(e){this.enabledRenderPasses[e]&&delete this.enabledRenderPasses[e]}isRenderPassEnabled(e){return!!this.enabledRenderPasses[e]}destroy(e){(e===!0||e&&e.geometry)&&this.geometry.destroy(),(e===!0||e&&e.material)&&this.material&&this.material.destroy(),super.destroy(e)}_render(e){e.batch.setObjectRenderer(e.plugins[this.pluginName]),this.skin&&this.skin.calculateJointMatrices(),e.plugins[this.pluginName].render(this)}getBoundingBox(){var e,t;if(!((e=this.geometry.positions)!=null&&e.min)||!((t=this.geometry.positions)!=null&&t.max))return;let n=x.transformMat4(this.geometry.positions.min,this.worldTransform.array),i=x.transformMat4(this.geometry.positions.max,this.worldTransform.array);for(let a=0;a<3;a++){let s=n[a];n[a]=Math.min(n[a],i[a]),i[a]=Math.max(s,i[a])}return be.from({min:n,max:i})}static createQuad(e=new le){return new X(qe.create(),e)}static createCube(e=new le){return new X(Ke.create(),e)}static createPlane(e=new le){return new X(Je.create(),e)}static createSphere(e=new le,t){return new X(tt.create(t),e)}}class Ft extends je.EventEmitter{constructor(e){super(),this.name=e,this.speed=1,this.loop=!1}play(e=ce.Ticker.shared){this.position=0,this._ticker||(this._update=()=>{this.update(e.deltaMS/1e3*this.speed)},this._ticker=e.add(this._update))}stop(){this._ticker&&this._update&&(this._ticker.remove(this._update),this._ticker=this._update=void 0)}update(e){this.position+=e,!(this.position<this.duration)&&(this.loop?this.position>this.duration&&(this.position=this.position%this.duration):(this.position=this.duration,this.stop()),this.emit("complete"))}}class dn extends Ft{constructor(e,t){super(t),this._duration=0,this._position=0,this._channels=[];for(let n of e)this._duration=Math.max(this._duration,n.duration);this._channels=e}get duration(){return this._duration}get position(){return this._position}set position(e){this._position=e;for(let t of this._channels)t.position=this._position}}class he{constructor(e,t,n=0,i,a,s){this.buffer=e,this.componentType=t,this.stride=n,this.componentCount=i,this.min=a,this.max=s}static from(e,t,n,i,a,s,o,l){switch(e){case 5125:return new he(new Uint32Array(n,i,a),e,s,t,o,l);case 5126:return new he(new Float32Array(n,i,a),e,s,t,o,l);case 5120:return new he(new Int8Array(n,i,a),e,s,t,o,l);case 5121:return new he(new Uint8Array(n,i,a),e,s,t,o,l);case 5122:return new he(new Int16Array(n,i,a),e,s,t,o,l);case 5123:return new he(new Uint16Array(n,i,a),e,s,t,o,l);default:throw new Error(`PIXI3D: Unknown component type "${e}".`)}}}class Lt{constructor(e,t){this.parent=e,this.joints=t,this._jointMatrices=[],this._jointNormalMatrices=[],this._transformIds=[],this.jointNormalMatrices=new Float32Array(this.joints.length*16),this.jointMatrices=new Float32Array(this.joints.length*16);for(let n=0;n<t.length;n++)this._transformIds.push(-1),this._jointMatrices.push(new Float32Array(this.jointMatrices.buffer,64*n,16)),this._jointNormalMatrices.push(new Float32Array(this.jointNormalMatrices.buffer,64*n,16))}calculateJointMatrices(){for(let e=0;e<this.joints.length;e++)this.joints[e].transform._worldID!==this._transformIds[e]&&(this._transformIds[e]=this.joints[e].transform._worldID,v.multiply(this.joints[e].worldTransform.array,this.joints[e].inverseBindMatrix,this._jointMatrices[e]),v.multiply(this.parent.transform.inverseWorldTransform.array,this._jointMatrices[e],this._jointMatrices[e]),v.invert(this._jointMatrices[e],this._jointNormalMatrices[e]),v.transpose(this._jointNormalMatrices[e],this._jointNormalMatrices[e]))}}class Ot extends V{constructor(e){super(),this.inverseBindMatrix=e}}class fn{constructor(e,t){this._output=e,this._stride=t,this._data=new Float32Array(t)}interpolate(e,t){let n=(e+0)*this._stride,i=(e+1)*this._stride;for(let a=0;a<this._stride;a++)this._output.length>i?this._data[a]=(1-t)*this._output[n+a]+t*this._output[i+a]:this._data[a]=this._output[n+a];return this._data}}class rt{constructor(e,t,n){this._input=e,this._output=t,this._stride=n,this._data=new Float32Array(n)}interpolate(e,t){const n=this._input[e+1]-this._input[e],i=(e+0)*this._stride*3,a=(e+1)*this._stride*3;for(let s=0;s<this._stride;s++)this._data[s]=rt.calculate(t,this._output[i+s+1*this._stride],this._output[a+s+1*this._stride],n*this._output[a+s],n*this._output[i+s+2*this._stride]);return this._data}static calculate(e,t,n,i,a){return(2*e**3-3*e**2+1)*t+(e**3-2*e**2+e)*i+(-2*e**3+3*e**2)*n+(e**3-e**2)*a}}class _n{constructor(e,t){this._output=e,this._stride=t,this._data=new Float32Array(t)}interpolate(e){for(let t=0;t<this._stride;t++)this._data[t]=this._output[e*this._stride+t];return this._data}}class Le{static create(e,t,n,i){switch(e){case"LINEAR":return new fn(n,i);case"CUBICSPLINE":return new rt(t,n,i);case"STEP":return new _n(n,i)}throw new Error(`PIXI3D: Unknown interpolation type "${e}"`)}}class Oe{constructor(e,t){this._position=0,this._frame=0,this._input=e,this._interpolation=t}get position(){return this._position}set position(e){this.setPosition(e)}get duration(){return this._input[this._input.length-1]}get frame(){return this._frame}get length(){return this._input.length}setPosition(e){this._position=e,this._frame=this.calculateFrame(this._position),this.updateTarget(this._interpolation.interpolate(this._frame,this.calculateFramePosition(this._frame,this._position)))}update(e){this.position+=e}calculateFramePosition(e,t){return e===this._input.length-1?1:(t-this._input[e])/(this._input[e+1]-this._input[e])}calculateFrame(e){if(e<this._input[0])return 0;for(let t=0;t<this._input.length-1;t++)if(e>=this._input[t]&&e<this._input[t+1])return t;return this._input.length-1}}class Pt extends Oe{constructor(e,t,n){super(t,n),this._transform=e}updateTarget(e){this._transform.rotationQuaternion.set(e[0],e[1],e[2],e[3])}}class mn extends Oe{constructor(e,t,n){super(t,n),this._transform=e}updateTarget(e){this._transform.scale.set(e[0],e[1],e[2])}}class gn{constructor(e){this._output=e,this._data=new Float32Array(4)}interpolate(e,t){let n=(e+0)*4,i=(e+1)*4,a=P.set(this._output[n],this._output[n+1],this._output[n+2],this._output[n+3],new Float32Array(4));if(this._output.length<=i)return P.normalize(a,this._data);let s=P.set(this._output[i],this._output[i+1],this._output[i+2],this._output[i+3],new Float32Array(4));return P.normalize(P.slerp(a,s,t,this._data),this._data)}}class pn extends Oe{constructor(e,t,n){super(t,n),this._transform=e}updateTarget(e){this._transform.position.set(e[0],e[1],e[2])}}class An extends Oe{constructor(e,t,n){super(t,n),this._weights=e}updateTarget(e){for(let t=0;t<e.length;t++)this._weights[t]=e[t]}}class vn{static create(e,t,n,i,a){if(i==="translation")return new pn(a.transform,e,Le.create(n,e,t,3));if(i==="scale")return new mn(a.transform,e,Le.create(n,e,t,3));if(i==="rotation")return n==="LINEAR"?new Pt(a.transform,e,new gn(t)):new Pt(a.transform,e,Le.create(n,e,t,4));if(i==="weights"){let s=a.children[0].targetWeights;return s?new An(s,e,Le.create(n,e,t,s.length)):void 0}throw new Error(`PIXI3D: Unknown channel path "${i}"`)}}class Pe{constructor(e,t){this._textures=[];var n;this._asset=e,this._materialFactory=t||new Ct,this._descriptor=this._asset.descriptor;for(let i=0;i<((n=this._descriptor.textures)==null?void 0:n.length);i++)this._textures.push(this.parseTexture(i))}static createModel(e,t){return new Pe(e,t).parseModel()}static createMesh(e,t,n=0){return new Pe(e,t).parseMesh(n)}parseBuffer(e){if(e===void 0)return;typeof e=="number"&&(e=this._asset.descriptor.accessors[e]);let t=this._descriptor.bufferViews[e.bufferView||0],n=e.byteOffset||0;t.byteOffset!==void 0&&(n+=t.byteOffset);let i=e.count*nt[e.type];t.byteStride!==void 0&&t.byteStride!==0&&(i=t.byteStride/Tn[e.componentType]*(e.count-1)+nt[e.type]);let a=this._asset.buffers[t.buffer];return he.from(e.componentType,nt[e.type],a,n,i,t.byteStride,e.min,e.max)}parseAnimation(e,t){typeof e=="number"&&(e=this._asset.descriptor.animations[e]);let n=[];for(let i of e.channels){let a=e.samplers[i.sampler],s=this.parseBuffer(a.input);if(s===void 0)continue;let o=this.parseBuffer(a.output);if(o===void 0)continue;let l=vn.create(s.buffer,o.buffer,a.interpolation||"LINEAR",i.target.path,t[i.target.node]);l&&n.push(l)}return new dn(n,e.name)}parseMaterial(e){typeof e=="number"&&(e=this._asset.descriptor.materials[e]);let t=new bt;if(!e)return this._materialFactory.create(t);e.occlusionTexture!==void 0&&(t.occlusionTexture=this._textures[e.occlusionTexture.index].clone(),t.occlusionTexture.strength=e.occlusionTexture.strength,t.occlusionTexture.texCoord=e.occlusionTexture.texCoord,e.occlusionTexture.extensions&&e.occlusionTexture.extensions.KHR_texture_transform&&(t.occlusionTexture.transform=e.occlusionTexture.extensions.KHR_texture_transform,e.occlusionTexture.extensions.KHR_texture_transform.texCoord!==void 0&&(t.occlusionTexture.texCoord=e.occlusionTexture.extensions.KHR_texture_transform.texCoord))),e.normalTexture!==void 0&&(t.normalTexture=this._textures[e.normalTexture.index].clone(),t.normalTexture.scale=e.normalTexture.scale||1,t.normalTexture.texCoord=e.normalTexture.texCoord,e.normalTexture.extensions&&e.normalTexture.extensions.KHR_texture_transform&&(t.normalTexture.transform=e.normalTexture.extensions.KHR_texture_transform,e.normalTexture.extensions.KHR_texture_transform.texCoord!==void 0&&(t.normalTexture.texCoord=e.normalTexture.extensions.KHR_texture_transform.texCoord))),e.emissiveTexture!==void 0&&(t.emissiveTexture=this._textures[e.emissiveTexture.index].clone(),t.emissiveTexture.texCoord=e.emissiveTexture.texCoord,e.emissiveTexture.extensions&&e.emissiveTexture.extensions.KHR_texture_transform&&(t.emissiveTexture.transform=e.emissiveTexture.extensions.KHR_texture_transform,e.emissiveTexture.extensions.KHR_texture_transform.texCoord!==void 0&&(t.emissiveTexture.texCoord=e.emissiveTexture.extensions.KHR_texture_transform.texCoord))),e.doubleSided!==void 0&&(t.doubleSided=e.doubleSided),e.emissiveFactor&&(t.emissiveFactor=e.emissiveFactor),e.alphaMode&&(t.alphaMode=e.alphaMode),e.alphaCutoff!==void 0&&(t.alphaCutoff=e.alphaCutoff);let n=e.pbrMetallicRoughness;return(n==null?void 0:n.metallicRoughnessTexture)!==void 0&&(t.metallicRoughnessTexture=this._textures[n.metallicRoughnessTexture.index].clone(),t.metallicRoughnessTexture.texCoord=n.metallicRoughnessTexture.texCoord,n.metallicRoughnessTexture.extensions&&n.metallicRoughnessTexture.extensions.KHR_texture_transform&&(t.metallicRoughnessTexture.transform=n.metallicRoughnessTexture.extensions.KHR_texture_transform,n.metallicRoughnessTexture.extensions.KHR_texture_transform.texCoord!==void 0&&(t.metallicRoughnessTexture.texCoord=n.metallicRoughnessTexture.extensions.KHR_texture_transform.texCoord))),n!=null&&n.baseColorFactor&&(t.baseColor=n.baseColorFactor),(n==null?void 0:n.baseColorTexture)!==void 0&&(t.baseColorTexture=this._textures[n.baseColorTexture.index].clone(),t.baseColorTexture.texCoord=n.baseColorTexture.texCoord,n.baseColorTexture.extensions&&n.baseColorTexture.extensions.KHR_texture_transform&&(t.baseColorTexture.transform=n.baseColorTexture.extensions.KHR_texture_transform,n.baseColorTexture.extensions.KHR_texture_transform.texCoord!==void 0&&(t.baseColorTexture.texCoord=n.baseColorTexture.extensions.KHR_texture_transform.texCoord))),(n==null?void 0:n.metallicFactor)!==void 0&&(t.metallic=n.metallicFactor),(n==null?void 0:n.roughnessFactor)!==void 0&&(t.roughness=n.roughnessFactor),e.extensions&&(t.unlit=e.extensions.KHR_materials_unlit!==void 0),this._materialFactory.create(t)}parseTexture(e){const t=this._descriptor.textures[e],n=this._asset.images[t.source],i=new p.Texture(new p.BaseTexture(n.baseTexture.resource,{wrapMode:R.WRAP_MODES.REPEAT,alphaMode:R.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA}));if(this._descriptor.samplers&&t.sampler!==void 0)switch(this._descriptor.samplers[t.sampler].wrapS){case 10497:i.baseTexture.wrapMode=R.WRAP_MODES.REPEAT;break;case 33648:i.baseTexture.wrapMode=R.WRAP_MODES.MIRRORED_REPEAT;break;case 33071:i.baseTexture.wrapMode=R.WRAP_MODES.CLAMP;break}return i}parseMesh(e){typeof e=="number"&&(e=this._asset.descriptor.meshes[e]);let t=e.weights||[];return e.primitives.map(n=>Object.assign(this.parsePrimitive(n),{name:e.name,targetWeights:t}))}parseSkin(e,t,n){return typeof e=="number"&&(e=this._asset.descriptor.skins[e]),new Lt(t,e.joints.map(i=>n[i]))}parsePrimitive(e){let{attributes:t,targets:n}=e,i=Object.assign(new pe,{indices:this.parseBuffer(e.indices),positions:this.parseBuffer(t.POSITION),normals:this.parseBuffer(t.NORMAL),tangents:this.parseBuffer(t.TANGENT),joints:this.parseBuffer(t.JOINTS_0),weights:this.parseBuffer(t.WEIGHTS_0),colors:this.parseBuffer(t.COLOR_0)});for(let s=0;;s++){let o=this.parseBuffer(t[`TEXCOORD_${s}`]);if(o===void 0)break;i.uvs=i.uvs||[],i.uvs.push(o)}if(n)for(let s=0;s<n.length;s++)i.targets=i.targets||[],i.targets.push({positions:this.parseBuffer(n[s].POSITION),normals:this.parseBuffer(n[s].NORMAL),tangents:this.parseBuffer(n[s].TANGENT)});let a;return e.material!==void 0?a=this.parseMaterial(this._asset.descriptor.materials[e.material]):a=this.parseMaterial(),new X(i,a)}parseNode(e){const t=this._asset.descriptor.nodes[e];let n;for(let a of this._asset.descriptor.skins||[]){const s=a.joints.indexOf(e);if(s>=0){const o=this.parseBuffer(a.inverseBindMatrices),l=o==null?void 0:o.buffer.slice(s*16,s*16+16);n=Object.assign(new Ot(l),{name:t.name})}}let i=n||Object.assign(new V,{name:t.name});return t.translation&&i.position.set(t.translation[0],t.translation[1],t.translation[2]),t.rotation&&i.rotationQuaternion.set(t.rotation[0],t.rotation[1],t.rotation[2],t.rotation[3]),t.scale&&i.scale.set(t.scale[0],t.scale[1],t.scale[2]),t.matrix&&i.transform.setFromMatrix(new I(t.matrix)),i}parseModel(){let e=this._descriptor.nodes.map((a,s)=>this.parseNode(s)),t=this._descriptor.scenes[this._asset.descriptor.scene||0],n=new Ue,i=(a,s)=>{let o=this._asset.descriptor.nodes[s].mesh,l;if(this._asset.descriptor.nodes[s].skin!==void 0&&(l=this.parseSkin(this._asset.descriptor.nodes[s].skin,e[s],e)),o!==void 0)for(let h of this.parseMesh(o))n.meshes.push(e[s].addChild(h)),n.meshes[n.meshes.length-1].skin=l;if(a.addChild(e[s]),!!this._asset.descriptor.nodes[s].children)for(let h of this._asset.descriptor.nodes[s].children)i(e[s],h)};for(let a of t.nodes)i(n,a);if(this._asset.descriptor.animations)for(let a of this._asset.descriptor.animations)n.animations.push(this.parseAnimation(a,e));return n}}const nt={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Tn={[5120]:1,[5121]:1,[5122]:2,[5123]:2,[5125]:4,[5126]:4};function Ut(r,e,t){for(let n of r.children)if(n instanceof X){const i=n.createInstance();i.name=n.name,t.push(e.addChild(i))}else if(n instanceof V){const i=e.addChild(new V);i.name=r.name,i.position=n.position,i.scale=n.scale,i.rotationQuaternion=n.rotationQuaternion,Ut(n,i,t)}}class Dt extends V{constructor(e){super(),this.meshes=[],Ut(e,this,this.meshes)}}class Ue extends V{constructor(){super(...arguments),this.animations=[],this.meshes=[]}static from(e,t){return Pe.createModel(e,t)}createInstance(){return new Dt(this)}getBoundingBox(){this.updateTransform();let e=new be,t=this.meshes[0].getBoundingBox();t&&(e.min=t.min,e.max=t.max);for(let n=1;n<this.meshes.length;n++){let i=this.meshes[n].getBoundingBox();i&&(e.encapsulate(i.min),e.encapsulate(i.max))}return e}}class xn extends V{constructor(){super(...arguments),this.type=W.point,this.color=new k(1,1,1),this.range=10,this.intensity=10,this.innerConeAngle=0,this.outerConeAngle=45}}class Bt{constructor(e,t){this.renderer=e,this.name=t,this.clearColor=new k(0,0,0,0)}get renderTexture(){return this._renderTexture}set renderTexture(e){this._renderTexture=e}clear(){if(this._renderTexture&&this.clearColor){const e=this.renderer.renderTexture.current;this.renderer.renderTexture.bind(this._renderTexture),this.renderer.renderTexture.clear(Array.from(this.clearColor.rgba)),this.renderer.renderTexture.bind(e||void 0)}}render(e){const t=this.renderer.renderTexture.current;this._renderTexture&&this.renderer.renderTexture.bind(this._renderTexture);for(let n of e)n.material&&n.material.render(n,this.renderer);this._renderTexture&&this.renderer.renderTexture.bind(t||void 0)}}var Sn={source:`#version VERSION

VERT_IN vec3 a_Position;
VERT_IN vec2 a_UV1;

VERT_OUT vec2 v_UV1;

void main() {
  v_UV1 = a_UV1;
  gl_Position = vec4(a_Position, 1.0);
}`},wn={source:`#version VERSION

#define FEATURES

#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
#else
  precision mediump float;
#endif

#ifdef WEBGL2
  out vec4 FRAG_COLOR;
#endif

FRAG_IN vec2 v_UV1;

uniform vec2 u_BlurScale;
uniform sampler2D u_FilterSampler;

void main() {
  vec4 color = vec4(0.0);

  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-3.0) * u_BlurScale.xy)) * (1.0/64.0);
  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-2.0) * u_BlurScale.xy)) * (6.0/64.0);
  color += texture2D(u_FilterSampler, v_UV1 + (vec2(-1.0) * u_BlurScale.xy)) * (15.0/64.0);
  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+0.0) * u_BlurScale.xy)) * (20.0/64.0);
  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+1.0) * u_BlurScale.xy)) * (15.0/64.0);
  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+2.0) * u_BlurScale.xy)) * (6.0/64.0);
  color += texture2D(u_FilterSampler, v_UV1 + (vec2(+3.0) * u_BlurScale.xy)) * (1.0/64.0);

  FRAG_COLOR = color;
}`};class yn{constructor(e){this.renderer=e,this._mesh=X.createQuad(),this._gaussianBlurShader=new _e(p.Program.from(se.build(Sn.source,[],e),se.build(wn.source,[],e)))}applyGaussianBlur(e){this.applyBlurScale(e.shadowTexture,e.filterTexture,new Float32Array([0,e.softness/e.shadowTexture.height])),this.applyBlurScale(e.filterTexture,e.shadowTexture,new Float32Array([e.softness/e.shadowTexture.width,0]))}applyBlurScale(e,t,n){this.renderer.renderTexture.bind(t),this.renderer.renderTexture.clear(),this._gaussianBlurShader.uniforms.u_FilterSampler=e,this._gaussianBlurShader.uniforms.u_BlurScale=n,this._gaussianBlurShader.render(this._mesh,this.renderer),this.renderer.renderTexture.bind(void 0)}}var En={source:`#version VERSION

#define FEATURES

vec4 _texture(sampler2D sampler, vec2 coord)
{
#ifdef WEBGL2
    return texture(sampler, coord);
#else
    return texture2D(sampler, coord);
#endif
}

vec4 _texture(samplerCube sampler, vec3 coord)
{
#ifdef WEBGL2
    return texture(sampler, coord);
#else
    return textureCube(sampler, coord);
#endif
}

VERT_IN vec3 a_Position;

#ifdef USE_SKINNING
  VERT_IN vec4 a_Joint1;
  VERT_IN vec4 a_Weight1;
#endif

uniform mat4 u_ViewProjectionMatrix;
uniform mat4 u_ModelMatrix;

#ifdef USE_SKINNING
  #ifdef USE_SKINNING_TEXTURE
    uniform sampler2D u_jointMatrixSampler;
  #else
    uniform mat4 u_jointMatrix[MAX_JOINT_COUNT];
  #endif
#endif

#ifdef USE_INSTANCING
  VERT_IN vec4 a_ModelMatrix0;
  VERT_IN vec4 a_ModelMatrix1;
  VERT_IN vec4 a_ModelMatrix2;
  VERT_IN vec4 a_ModelMatrix3;
#endif

// these offsets assume the texture is 4 pixels across
#define ROW0_U ((0.5 + 0.0) / 4.0)
#define ROW1_U ((0.5 + 1.0) / 4.0)
#define ROW2_U ((0.5 + 2.0) / 4.0)
#define ROW3_U ((0.5 + 3.0) / 4.0)

#ifdef USE_SKINNING
mat4 getJointMatrix(float boneNdx) {
  #ifdef USE_SKINNING_TEXTURE
    float v = (boneNdx + 0.5) / float(MAX_JOINT_COUNT);
    return mat4(
      _texture(u_jointMatrixSampler, vec2(ROW0_U, v)), 
      _texture(u_jointMatrixSampler, vec2(ROW1_U, v)), 
      _texture(u_jointMatrixSampler, vec2(ROW2_U, v)), 
      _texture(u_jointMatrixSampler, vec2(ROW3_U, v))
    );
  #else
    return u_jointMatrix[int(boneNdx)];
  #endif
}

mat4 getSkinningMatrix() {
  mat4 skin = mat4(0);
  skin += 
    a_Weight1.x * getJointMatrix(a_Joint1.x) +
    a_Weight1.y * getJointMatrix(a_Joint1.y) +
    a_Weight1.z * getJointMatrix(a_Joint1.z) +
    a_Weight1.w * getJointMatrix(a_Joint1.w);
  return skin;
}
#endif

void main() {
  mat4 modelMatrix = u_ModelMatrix;
  #ifdef USE_INSTANCING
    modelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);
  #endif
  vec4 pos = vec4(a_Position, 1.0);
  #ifdef USE_SKINNING
    pos = getSkinningMatrix() * pos;
  #endif
  gl_Position = u_ViewProjectionMatrix * modelMatrix * pos;
}`},bn={source:`#version VERSION

#define FEATURES

#if defined(WEBGL1)
  #extension GL_OES_standard_derivatives : enable
#endif

#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
#else
  precision mediump float;
#endif

#ifdef WEBGL2
  out vec4 FRAG_COLOR;
#endif

void main() {
  float depth = gl_FragCoord.z;
  float dx = 0.0;
  float dy = 0.0;

  #if defined(WEBGL2) || defined(GL_OES_standard_derivatives)
    dx = dFdx(depth);
    dy = dFdy(depth);
  #endif

  float moment2 = depth * depth + 0.25 * (dx * dx + dy * dy);
  FRAG_COLOR = vec4(1.0 - depth, 1.0 - moment2, 0.0, 0.0);
}`};class Mn{constructor(){this._maxInstances=20,this._modelMatrix=[new p.Buffer,new p.Buffer,new p.Buffer,new p.Buffer],this.expandBuffers(this._maxInstances)}expandBuffers(e){for(;e>this._maxInstances;)this._maxInstances+=Math.floor(this._maxInstances*.5);for(let t=0;t<4;t++)this._modelMatrix[t].update(new Float32Array(4*this._maxInstances))}updateBuffers(e){e.length>this._maxInstances&&this.expandBuffers(e.length);for(let t=0;t<e.length;t++){const n=e[t].worldTransform.array;for(let i=0;i<4;i++)this._modelMatrix[i].data.set(n.slice(i*4,i*4+4),t*4)}for(let t=0;t<4;t++)this._modelMatrix[t].update()}addGeometryAttributes(e){for(let t=0;t<4;t++)e.addAttribute(`a_ModelMatrix${t}`,this._modelMatrix[t],4,!1,void 0,0,void 0,!0)}}var it;(r=>{function e(t,n=[]){return t.context.webGLVersion===1&&n.push("WEBGL1 1"),t.context.webGLVersion===2&&n.push("WEBGL2 1"),n}r.build=e})(it||(it={}));class De extends _e{constructor(e,t=[]){t=it.build(e,t),super(p.Program.from(se.build(En.source,t,e),se.build(bn.source,t,e))),this._instancing=new Mn}get maxSupportedJoints(){return 0}createShaderGeometry(e,t){let n=new p.Geometry;return e.indices&&(e.indices.buffer.BYTES_PER_ELEMENT===1?n.addIndex(new p.Buffer(new Uint16Array(e.indices.buffer))):n.addIndex(new p.Buffer(e.indices.buffer))),e.positions&&n.addAttribute("a_Position",new p.Buffer(e.positions.buffer),3,!1,e.positions.componentType,e.positions.stride),t&&this._instancing.addGeometryAttributes(n),n}get name(){return"shadow-shader"}render(e,t,n){if(e.instances.length>0){const i=e.instances.filter(a=>a.worldVisible&&a.renderable);if(i.length===0)return;this._instancing.updateBuffers(i)}super.render(e,t,n)}updateUniforms(e,t){this.uniforms.u_ModelMatrix=e.worldTransform.array,this.uniforms.u_ViewProjectionMatrix=t.lightViewProjection}}class at extends De{constructor(e){const t=at.getMaxJointCount(e)-1;super(e,["USE_SKINNING 1","MAX_JOINT_COUNT "+t]),this._maxSupportedJoints=t}get maxSupportedJoints(){return this._maxSupportedJoints}static getMaxJointCount(e){let t=8,n=z.getMaxVertexUniformVectors(e)-t;return Math.floor(n/4)}createShaderGeometry(e,t){let n=super.createShaderGeometry(e,t);return e.joints&&n.addAttribute("a_Joint1",new p.Buffer(e.joints.buffer),4,!1,e.joints.componentType,e.joints.stride),e.weights&&n.addAttribute("a_Weight1",new p.Buffer(e.weights.buffer),4,!1,e.weights.componentType,e.weights.stride),n}get name(){return"skinned-shadow-shader"}updateUniforms(e,t){super.updateUniforms(e,t),e.skin&&(this.uniforms.u_jointMatrix=e.skin.jointMatrices)}}const st=256;class Gt extends De{constructor(e){super(e,["USE_SKINNING 1","USE_SKINNING_TEXTURE 1","MAX_JOINT_COUNT "+st]),this._jointMatrixTexture=new Ae(st)}static isSupported(e){return Ae.isSupported(e)}get maxSupportedJoints(){return st}createShaderGeometry(e,t){let n=super.createShaderGeometry(e,t);return e.joints&&n.addAttribute("a_Joint1",new p.Buffer(e.joints.buffer),4,!1,e.joints.componentType,e.joints.stride),e.weights&&n.addAttribute("a_Weight1",new p.Buffer(e.weights.buffer),4,!1,e.weights.componentType,e.weights.stride),n}get name(){return"skinned-shadow-shader"}updateUniforms(e,t){super.updateUniforms(e,t),e.skin&&(this._jointMatrixTexture.updateBuffer(e.skin.jointMatrices),this.uniforms.u_jointMatrixSampler=this._jointMatrixTexture)}}class Rn{constructor(e){this.renderer=e,this._state=Object.assign(new p.State,{depthTest:!0,clockwiseFrontFace:!1,culling:!0,blendMode:R.BLEND_MODES.NONE}),this._shadowShader=new De(this.renderer),this._instancedShadowShader=new De(this.renderer,["USE_INSTANCING 1"])}getSkinningShader(){return this._textureShader||this._skinningShader?this._textureShader||this._skinningShader:(Gt.isSupported(this.renderer)?this._textureShader=new Gt(this.renderer):(A.Debug.warn(fe.meshVertexSkinningFloatingPointTexturesNotSupported),this._skinningShader=new at(this.renderer)),this._textureShader||this._skinningShader)}render(e,t){let n=e.instances.length>0?this._instancedShadowShader:this._shadowShader;if(e.skin){let i=this.getSkinningShader();i&&e.skin.joints.length>i.maxSupportedJoints?A.Debug.error(fe.meshVertexSkinningNumberOfJointsNotSupported,{joints:e.skin.joints.length,maxJoints:i.maxSupportedJoints}):n=i}n&&(n.updateUniforms(e,t),n.render(e,this.renderer,this._state))}}class Vt{constructor(e,t="shadow"){this.renderer=e,this.name=t,this._lights=[],this._filter=new yn(e),this._shadow=new Rn(e)}addShadowCastingLight(e){this._lights.indexOf(e)<0&&this._lights.push(e)}removeShadowCastingLight(e){const t=this._lights.indexOf(e);t>=0&&this._lights.splice(t,1)}clear(){for(let e of this._lights)e.clear()}render(e){if(e.length===0||this._lights.length===0)return;const t=this.renderer.renderTexture.current;for(let n of this._lights){this.renderer.renderTexture.bind(n.shadowTexture),n.updateLightViewProjection();for(let i of e)this._shadow.render(i,n);n.softness>0&&this._filter.applyGaussianBlur(n)}this.renderer.renderTexture.bind(t||void 0)}}class In extends p.BatchGeometry{constructor(){super(),this.addAttribute("aMatrix0",this._buffer,4,!1,R.TYPES.FLOAT),this.addAttribute("aMatrix1",this._buffer,4,!1,R.TYPES.FLOAT),this.addAttribute("aMatrix2",this._buffer,4,!1,R.TYPES.FLOAT),this.addAttribute("aMatrix3",this._buffer,4,!1,R.TYPES.FLOAT)}}var Cn={source:`precision highp float;

attribute vec2 aVertexPosition;

attribute vec4 aMatrix0;
attribute vec4 aMatrix1;
attribute vec4 aMatrix2;
attribute vec4 aMatrix3;

attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void) {
  mat4 modelMatrix = mat4(aMatrix0, aMatrix1, aMatrix2, aMatrix3);

  gl_Position = modelMatrix * vec4(aVertexPosition.xy, 0.0, 1.0);

  vTextureCoord = vec2(aTextureCoord.x, aTextureCoord.y);
  vTextureId = aTextureId;
  vColor = aColor * tint;
}`},Nn={source:`varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = vColor * vec4(color.rgb, color.a);
}`};const Fn=L.get(F,"BatchRenderer")||L.get(F,"AbstractBatchRenderer");class ot extends Fn{constructor(e){super(e),this.shaderGenerator=new p.BatchShaderGenerator(Cn.source,Nn.source),this.geometryClass=In,this.vertexSize=22,Object.assign(this.state,{culling:!1,clockwiseFrontFace:!1,depthTest:!0})}packInterleavedGeometry(e,t,n,i,a){const{uint32View:s,float32View:o}=t,l=i/this.vertexSize,h=e.uvs,u=e.indices,d=e.vertexData,c=e._texture.baseTexture._batchLocation,f=Math.min(e.worldAlpha,1),m=f<1&&e._texture.baseTexture.alphaMode?je.premultiplyTint(e._tintRGB,f):e._tintRGB+(f*255<<24);for(let _=0;_<d.length;_+=2){o[i++]=d[_],o[i++]=d[_+1],o[i++]=h[_],o[i++]=h[_+1],s[i++]=m,o[i++]=c;let g=e.modelViewProjection.array;for(let T=0;T<16;T++)o[i++]=g[T]}for(let _=0;_<u.length;_++)n[a++]=l+u[_]}}C.installRendererPlugin("sprite3d",ot);class Ht extends p.ObjectRenderer{constructor(e){super(e),this.renderer=e,this._meshes=[],this._sprites=[],this.materialPass=new Bt(this.renderer,"material"),this.shadowPass=new Vt(this.renderer,"shadow"),this.renderPasses=[this.shadowPass,this.materialPass],e.on("prerender",()=>{for(let t of this.renderPasses)t.clear&&t.clear()}),this._spriteRenderer=new ot(e)}render(e){e.isSprite?this._sprites.push(e):this._meshes.push(e)}flush(){this.sort();for(let e of this.renderPasses)e.render(this._meshes.filter(t=>t.isRenderPassEnabled(e.name)));if(this._meshes=[],this._sprites.length>0){this._spriteRenderer.start();for(let e of this._sprites)this._spriteRenderer.render(e);this._spriteRenderer.stop(),this._sprites=[]}}sort(){this._meshes.sort((e,t)=>!e.material||!t.material?0:e.material.renderSortType!==t.material.renderSortType?e.material.renderSortType===Te.transparent?1:-1:e.renderSortOrder===t.renderSortOrder?0:e.renderSortOrder<t.renderSortOrder?-1:1),this._sprites.sort((e,t)=>e.zIndex!==t.zIndex?e.zIndex-t.zIndex:t.distanceFromCamera-e.distanceFromCamera)}enableShadows(e,t){let n=e instanceof Ue?e.meshes:[e];for(let i of n)t&&i.material instanceof le&&(i.material.shadowCastingLight=t),i.enableRenderPass(this.shadowPass.name);t&&this.shadowPass.addShadowCastingLight(t)}disableShadows(e){let t=e instanceof Ue?e.meshes:[e];for(let n of t)n.material instanceof le&&(n.material.shadowCastingLight=void 0),n.disableRenderPass(this.shadowPass.name)}}C.installRendererPlugin("pipeline",Ht);const Ln=L.get(F,"ArrayResource")||L.get(F,"resources").ArrayResource,On=L.get(F,"BaseImageResource")||L.get(F,"resources").BaseImageResource;class jt extends Ln{constructor(e,t){super(e),this.target=t}upload(e,t){e.gl.pixelStorei(e.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t.alphaMode===R.ALPHA_MODES.UNPACK);for(let n=0;n<this.items.length;n++){const i=this.items[n].resource;i instanceof Ye&&e.gl.texImage2D(this.target,n,t.format,i.width,i.height,0,t.format,t.type,i.data),i instanceof On&&e.gl.texImage2D(this.target,n,t.format,t.format,t.type,i.source)}return!0}}const Pn=L.get(F,"CubeResource")||L.get(F,"resources").CubeResource;class lt extends Pn{constructor(e,t=1){super(e),this.levels=t}style(e){let t=e.gl;return t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),this.levels>1?t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MIN_FILTER,t.LINEAR_MIPMAP_LINEAR):t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MIN_FILTER,t.LINEAR),!0}}class te extends p.BaseTexture{constructor(){super(...arguments),this.cubemapFormat=ve.ldr}static get faces(){return["posx","negx","posy","negy","posz","negz"]}get levels(){return this.resource.levels}static fromFaces(e){const t=Array.isArray(e)?e:[e],n=te.faces.map((i,a)=>new jt(t.map(s=>s[i]),R.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X+a));return new te(new lt(n,t.length))}static fromColors(e,t=e,n=e,i=e,a=e,s=e){const o=[],l=[e,t,n,i,a,s];for(let h=0;h<l.length;h++){let u=new Ye(new Uint8Array(l[h].rgba.map(c=>c*255)),{width:1,height:1}),d=new p.Texture(new p.BaseTexture(u,{type:R.TYPES.UNSIGNED_BYTE,format:R.FORMATS.RGB,alphaMode:R.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA}));o.push(new jt([d],R.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X+h))}return new te(new lt(o,1))}}class Un{constructor(e){this.json=e}get format(){return ve.ldr}get mipmaps(){return this.json}}class Dn{constructor(e){this.json=e}get format(){return this.json.format}get mipmaps(){return this.json.mipmaps}}var Be;(r=>{function e(t){return t.version===2?new Dn(t):new Un(t)}r.getFileVersion=e})(Be||(Be={}));const zt={use:function(r,e){if(r.extension!=="cubemap")return e();const t=this,n=Be.getFileVersion(r.data),i=n.mipmaps.map(l=>te.faces.map(h=>r.url.substring(0,r.url.lastIndexOf("/")+1)+l.replace("{{face}}",h)));let a=i.reduce((l,h)=>l.concat(h),[]);t.add(a.filter(l=>!t.resources[l]).map(l=>({parentResource:r,url:l})));let s=0,o=t.onLoad.add((l,h)=>{if(a.includes(h.url)&&++s===a.length){const u=i.map(c=>({posx:p.Texture.from(c[0]),negx:p.Texture.from(c[1]),posy:p.Texture.from(c[2]),negy:p.Texture.from(c[3]),posz:p.Texture.from(c[4]),negz:p.Texture.from(c[5])}));let d=te.fromFaces(u);d.cubemapFormat=n.format,r.cubemap=d,o.detach(),e()}})},add:function(){C.setLoaderResourceExtensionType("cubemap",ae.json)},test(r){return r.includes(".cubemap")},async load(r){if(!C.assets)throw new Error("PIXI3D: This feature is only available when using PixiJS v7+");const e=await(await me.settings.ADAPTER.fetch(r)).json(),t=Be.getFileVersion(e),n=t.mipmaps.map(s=>te.faces.map(o=>r.substring(0,r.lastIndexOf("/")+1)+s.replace("{{face}}",o))),i=[];for(let s of n){let o={posx:await C.assets.load(s[0]),negx:await C.assets.load(s[1]),posy:await C.assets.load(s[2]),negy:await C.assets.load(s[3]),posz:await C.assets.load(s[4]),negz:await C.assets.load(s[5])};i.push(o)}let a=te.fromFaces(i);return a.cubemapFormat=t.format,a}};C.installLoaderPlugin("cubemap",zt);const Bn=["glsl","vert","frag"],kt={use:(r,e)=>{e()},add:function(){for(let r of Bn)C.setLoaderResourceExtensionType(r,ae.text)},test(r){return r.includes(".glsl")||r.includes(".vert")||r.includes(".frag")},async load(r){return await(await me.settings.ADAPTER.fetch(r)).text()}};C.installLoaderPlugin("shader",kt);var Gn={source:`attribute vec3 a_Position;

varying vec3 v_Position;

uniform mat4 u_ModelMatrix;
uniform mat4 u_View;
uniform mat4 u_Projection;

void main() {
  v_Position = a_Position.xyz;

  // Converting the view to 3x3 matrix and then back to 4x4 matrix 
  // removes the translation. We do this because we want the skybox to 
  // be centered around the camera.
  gl_Position = u_Projection * mat4(mat3(u_View)) * u_ModelMatrix * vec4(a_Position, 1.0);
}`},Vn={source:`varying vec3 v_Position;

uniform samplerCube u_EnvironmentSampler;
uniform bool u_RGBE;
uniform float u_Exposure;

const float GAMMA = 2.2;
const float INV_GAMMA = 1.0 / GAMMA;

// linear to sRGB approximation
// see http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html
vec3 linearToSRGB(vec3 color)
{
    return pow(color, vec3(INV_GAMMA));
}

vec3 decodeRGBE(vec4 rgbe) {
  vec3 vDecoded;
  float fExp = rgbe.a * 255.0 - 128.0;
  vDecoded = rgbe.rgb * exp2(fExp);
  return vDecoded;
}

void main() {
  vec4 color = textureCube(u_EnvironmentSampler, v_Position);
  if (u_RGBE) {
    color = vec4(decodeRGBE(color), 1.0);
  }
  gl_FragColor = vec4(linearToSRGB(color.rgb * u_Exposure), 1.0);
}`};class Hn extends Ee{constructor(e){super(),this.exposure=1,this._cubemap=e,this.state=Object.assign(new p.State,{culling:!0,clockwiseFrontFace:!0,depthTest:!0,depthMask:!1})}get cubemap(){return this._cubemap}set cubemap(e){e!==this._cubemap&&(this._cubemap.valid||(this._shader=void 0),this._cubemap=e)}updateUniforms(e,t){let n=this.camera||H.main;t.uniforms.u_ModelMatrix=e.worldTransform.array,t.uniforms.u_View=n.view.array,t.uniforms.u_Projection=n.projection.array,t.uniforms.u_EnvironmentSampler=this.cubemap,t.uniforms.u_RGBE=this.cubemap.cubemapFormat===ve.rgbe8,t.uniforms.u_Exposure=this.exposure}render(e,t){t.gl.depthMask(!1),super.render(e,t),t.gl.depthMask(!0)}createShader(){if(this.cubemap.valid)return new _e(p.Program.from(Gn.source,Vn.source))}}class ht extends V{constructor(e){super(),this._mesh=this.addChild(X.createCube(new Hn(e))),this._mesh.renderSortOrder=-1}get camera(){return this._mesh.material.camera}set camera(e){this._mesh.material.camera=e}get exposure(){return this._mesh.material.exposure}set exposure(e){this._mesh.material.exposure=e}get cubemap(){return this._mesh.material.cubemap}set cubemap(e){this._mesh.material.cubemap=e}static from(e){return new ht(te.fromFaces(e))}}var jn={source:`#version 100

attribute vec3 a_Position;

uniform mat4 u_ModelViewProjection;

void main() {
  gl_Position = u_ModelViewProjection * vec4(a_Position, 1.0);
}`},zn={source:`#version 100

#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
#else
  precision mediump float;
#endif

uniform vec3 u_Id;

void main() {
  gl_FragColor = vec4(u_Id / 255.0, 1.0);
}`};class kn{constructor(e,t){this._renderer=e,this._update=0,this._matrix=new Float32Array(16),this._pixels=new Uint8Array(t*t*4),this._output=p.RenderTexture.create({width:t,height:t,resolution:1}),this._shader=new _e(p.Program.from(jn.source,zn.source)),this._output.framebuffer.addDepthTexture()}destroy(){this._output.destroy(!0),this._shader.destroy()}resizeToAspect(){const e=this._renderer.width/this._renderer.height,t=Math.floor(this._output.height*e);this._output.width!==t&&(this._pixels=new Uint8Array(t*this._output.height*4),this._output.resize(t,this._output.height))}containsId(e,t,n){const{width:i,height:a}=this._renderer.screen;e=Math.floor(e/i*this._output.width),t=Math.floor((a-t)/a*this._output.height);for(let s=0;s<3;s++)if(n[s]!==this._pixels[(t*this._output.width+e)*4+s])return!1;return!0}update(e){if(this._renderer.renderTexture.bind(this._output),this._update++%2===0){this._renderer.renderTexture.clear();for(let t of e)this.renderHitArea(t)}else{const t=this._renderer.gl;t.readPixels(0,0,this._output.width,this._output.height,t.RGBA,t.UNSIGNED_BYTE,this._pixels)}this._renderer.renderTexture.bind(void 0)}renderHitArea(e){const t=this._shader.uniforms,n=e.object instanceof X?[e.object]:e.object.meshes,i=e.camera||H.main;for(let a of n)t.u_Id=e.id,t.u_ModelViewProjection=v.multiply(i.viewProjection.array,a.transform.worldTransform.array,this._matrix),this._shader.render(a,this._renderer)}}class ue{constructor(e){this.renderer=e,this._hitAreas=[],this._map=new kn(this.renderer,128),ce.Ticker.shared.add(this._update,this,ce.UPDATE_PRIORITY.LOW),ue.main||(ue.main=this)}_update(){if(!this.renderer.plugins)return;let e=C.getInteractionPlugin(this.renderer);e&&e.hitTest(new U.Point(0,0)),this._hitAreas.length>0&&(this._map.resizeToAspect(),this._map.update(this._hitAreas),this._hitAreas=[])}destroy(){this===ue.main&&(ue.main=void 0),ce.Ticker.shared.remove(this._update,this)}containsHitArea(e,t,n){return this._hitAreas.indexOf(n)<0&&this._hitAreas.push(n),this._map.containsId(e,t,n.id)}}C.installRendererPlugin("picking",ue);var ut;(r=>{let e=0;function t(){return e++,new Uint8Array([e>>16&255,e>>8&255,e&255])}r.next=t})(ut||(ut={}));class Qn{constructor(e,t){this.object=e,this.camera=t,this.id=ut.next()}contains(e,t){return ue.main.containsHitArea(e,t,this)}}var Me=(r=>(r.low="low",r.medium="medium",r.high="high",r))(Me||{}),Ge;(r=>{function e(i,a,s){let o=n(i,s);return p.RenderTexture.create({width:a,height:a,type:o,scaleMode:t(i)})}r.create=e;function t(i){return z.supportsFloatLinear(i)?R.SCALE_MODES.LINEAR:R.SCALE_MODES.NEAREST}function n(i,a){if(a===Me.high){if(z.isFloatFramebufferSupported(i))return R.TYPES.FLOAT;if(z.isHalfFloatFramebufferSupported(i))return R.TYPES.HALF_FLOAT}return a===Me.medium&&z.isHalfFloatFramebufferSupported(i)?R.TYPES.HALF_FLOAT:R.TYPES.UNSIGNED_BYTE}})(Ge||(Ge={}));var Ve;(r=>{const e=new Float32Array(16),t=new Float32Array(16),n=new Float32Array(4),i=new Float32Array(3),a=new Float32Array(3),s=new Float32Array(3),o=new Float32Array(3);function l(u){if(u.light.type!==W.directional)return;let d=u.shadowArea/2,c=d*2/u.shadowArea,f=v.ortho(-d,d,-d,d,-d,d,e),m=u.light,_=u.camera||H.main;_&&u.followCamera?(x.scale(_.worldTransform.forward.array,d,o),x.add(_.worldTransform.position.array,o,s),x.transformQuat(s,P.conjugate(u.light.worldTransform.rotation.array,n),i),i[0]=c*Math.floor(i[0]/c),i[1]=c*Math.floor(i[1]/c),x.transformQuat(i,m.worldTransform.rotation.array,i),x.add(i,m.worldTransform.forward.array,a),v.lookAt(i,a,m.worldTransform.up.array,t),v.multiply(f,t,u.lightViewProjection)):(x.add(m.worldTransform.position.array,u.light.worldTransform.forward.array,s),v.lookAt(m.worldTransform.position.array,s,m.worldTransform.up.array,t),v.multiply(f,t,u.lightViewProjection))}r.calculateDirectionalLightViewProjection=l;function h(u){if(u.light.type!==W.spot)return;let d=u.light;v.perspective(d.outerConeAngle*U.DEG_TO_RAD*2,1,2,d.range,e),x.add(d.worldTransform.position.array,d.worldTransform.forward.array,s),v.lookAt(d.worldTransform.position.array,s,d.worldTransform.up.array,t),v.multiply(e,t,u.lightViewProjection)}r.calculateSpotLightViewProjection=h})(Ve||(Ve={}));class Wn{constructor(e,t,n){if(this.renderer=e,this.light=t,this._lightViewProjection=new Float32Array(16),this.softness=0,this.shadowArea=50,this.followCamera=!0,t.type===W.point)throw new Error("PIXI3D: Only directional and spot lights are supported as shadow casters.");const{shadowTextureSize:i=1024,quality:a=Me.medium}=n||{};this._shadowTexture=Ge.create(e,i,a),this._shadowTexture.baseTexture.framebuffer.addDepthTexture(),this._filterTexture=Ge.create(e,i,a)}get lightViewProjection(){return this._lightViewProjection}get shadowTexture(){return this._shadowTexture}get filterTexture(){return this._filterTexture}destroy(){this._shadowTexture.destroy(!0),this._filterTexture.destroy(!0)}clear(){this.renderer.renderTexture.bind(this._shadowTexture),this.renderer.renderTexture.clear([0,0,0,0],this.renderer.gl.COLOR_BUFFER_BIT|this.renderer.gl.DEPTH_BUFFER_BIT),this.renderer.renderTexture.bind(void 0)}updateLightViewProjection(){this.light.type===W.directional?Ve.calculateDirectionalLightViewProjection(this):this.light.type===W.spot&&Ve.calculateSpotLightViewProjection(this)}static isMediumQualitySupported(e){return z.isHalfFloatFramebufferSupported(e)}static isHighQualitySupported(e){return z.isFloatFramebufferSupported(e)}}class Xn extends ct.Sprite{constructor(e,t){super(),this.renderer=e,this._tickerRender=()=>{};let{width:n=512,height:i=512,objectToRender:a,resolution:s=1}=t||{};this._renderTexture=p.RenderTexture.create({width:n,height:i,resolution:s}),this._renderTexture.rotate=8,this._renderTexture.baseTexture.framebuffer.depth=!0,this._texture=this._renderTexture,(!t||!t.width||!t.height)&&e.on("prerender",()=>{this._renderTexture.resize(e.screen.width,e.screen.height)}),a&&(this._tickerRender=()=>{if(C.isRendererDestroyed(e)){ce.Ticker.shared.remove(this._tickerRender);return}this.worldVisible&&this.worldAlpha>0&&this.renderable&&a&&this.renderObject(a)},ce.Ticker.shared.add(this._tickerRender))}get renderTexture(){return this._renderTexture}setResolution(e){this._renderTexture.setResolution(e),this._renderTexture.resize(this._renderTexture.width,this._renderTexture.height,!0)}destroy(e){ce.Ticker.shared.remove(this._tickerRender),super.destroy(e)}renderObject(e){C.render(this.renderer,e,this.renderTexture)}}function Jn(r,e){return Math.abs(r-e)<=Kn*Math.max(1,Math.abs(r),Math.abs(e))}const Kn=1e-6;class qn{constructor(e,t){this.distance=t,this._normal=new y,this._normal=e.normalize(this._normal)}get normal(){return this._normal}rayCast(e){const t=y.dot(e.direction,this.normal);return Jn(t,0)?0:(-y.dot(e.origin,this.normal)-this.distance)/t}}var He=(r=>(r.spherical="spherical",r.cylindrical="cylindrical",r))(He||{});class Yn extends ct.Sprite{constructor(e){super(e),this._pixelsPerUnit=100,this.distanceFromCamera=0,this.modelViewProjection=new I,this.pluginName="pipeline"}get pixelsPerUnit(){return this._pixelsPerUnit}set pixelsPerUnit(e){e!==this._pixelsPerUnit&&(this._transformID=-1,this._pixelsPerUnit=e)}calculateVertices(){const e=this._texture;if(this._transformID===this.transform._worldID&&this._textureID===e._updateID)return;this._textureID!==e._updateID&&(this.uvs=this._texture._uvs.uvsFloat32),this._transformID=this.transform._worldID,this._textureID=e._updateID;const t=this.transform.worldTransform,n=e.orig,i=this._anchor,a=e.trim?e.trim.x-i._x*n.width:-i._x*n.width,s=e.trim?a+e.trim.width:a+n.width,o=e.trim?e.trim.y-i._y*n.height:-i._y*n.height,l=e.trim?o+e.trim.height:o+n.height;if(this.vertexData[0]=(t.a*a+t.c*-o)/this._pixelsPerUnit,this.vertexData[1]=(t.d*-o+t.b*a)/this._pixelsPerUnit,this.vertexData[2]=(t.a*s+t.c*-o)/this._pixelsPerUnit,this.vertexData[3]=(t.d*-o+t.b*s)/this._pixelsPerUnit,this.vertexData[4]=(t.a*s+t.c*-l)/this._pixelsPerUnit,this.vertexData[5]=(t.d*-l+t.b*s)/this._pixelsPerUnit,this.vertexData[6]=(t.a*a+t.c*-l)/this._pixelsPerUnit,this.vertexData[7]=(t.d*-l+t.b*a)/this._pixelsPerUnit,this.roundPixels){const u=me.settings.RESOLUTION;for(var h=0;h<this.vertexData.length;++h)this.vertexData[h]=Math.round((this.vertexData[h]*u|0)/u)}}}const Qt=new Float32Array(3);class Zn extends V{constructor(e){super(),this._modelView=new Float32Array(16),this._sprite=new Yn(e),this._sprite.anchor.set(.5)}get billboardType(){return this._billboardType}set billboardType(e){e!==this._billboardType&&(this._billboardType=e,this._cameraTransformId=void 0)}get pixelsPerUnit(){return this._sprite.pixelsPerUnit}set pixelsPerUnit(e){this._sprite.pixelsPerUnit=e}get renderSortOrder(){return this._sprite.zIndex}set renderSortOrder(e){this._sprite.zIndex=e}get tint(){return this._sprite.tint}set tint(e){this._sprite.tint=e}destroy(e){super.destroy(e),this._sprite.destroy(e)}_render(e){const t=this.camera||H.main;if(t.transformId!==this._cameraTransformId||this._parentID!==this.transform._worldID){const n=this.worldTransform.scaling;switch(v.multiply(t.view.array,this.worldTransform.array,this._modelView),this._billboardType){case He.spherical:{this._modelView[0]=n.x,this._modelView[1]=0,this._modelView[2]=0,this._modelView[3]=0,this._modelView[4]=0,this._modelView[5]=n.y,this._modelView[6]=0,this._modelView[7]=0;break}case He.cylindrical:{this._modelView[0]=n.x,this._modelView[1]=0,this._modelView[2]=0,this._modelView[3]=0,this._modelView[8]=0,this._modelView[9]=0,this._modelView[10]=1,this._modelView[11]=0;break}}v.multiply(t.projection.array,this._modelView,this._sprite.modelViewProjection.array),this._parentID=this.transform._worldID,this._cameraTransformId=t.transformId;const i=x.subtract(t.worldTransform.position.array,this.worldTransform.position.array,Qt),a=x.scale(t.worldTransform.forward.array,x.dot(i,t.worldTransform.forward.array),Qt);this._sprite.distanceFromCamera=x.squaredMagnitude(a)}this._sprite.worldAlpha=this.worldAlpha,this._sprite.render(e)}get anchor(){return this._sprite.anchor}set anchor(e){this._sprite.anchor=e}get texture(){return this._sprite.texture}set texture(e){this._sprite.texture=e}get blendMode(){return this._sprite.blendMode}set blendMode(e){this._sprite.blendMode=e}}return A.AABB=be,A.Animation=Ft,A.Camera=H,A.CameraOrbitControl=an,A.Color=k,A.CompositeSprite=Xn,A.Container3D=V,A.Cubemap=te,A.CubemapFormat=ve,A.CubemapLoader=zt,A.CubemapResource=lt,A.ImageBasedLighting=$e,A.InstancedModel=Dt,A.InstancedStandardMaterial=Et,A.Joint=Ot,A.Light=xn,A.LightType=W,A.LightingEnvironment=oe,A.Mat4=v,A.Material=Ee,A.MaterialRenderPass=Bt,A.MaterialRenderSortType=Te,A.Matrix4x4=I,A.Mesh3D=X,A.MeshGeometry3D=pe,A.MeshShader=_e,A.Model=Ue,A.PickingHitArea=Qn,A.PickingInteraction=ue,A.Plane=qn,A.Point3D=y,A.Quat=P,A.Quaternion=G,A.Ray=Xe,A.ShaderSourceLoader=kt,A.ShadowCastingLight=Wn,A.ShadowQuality=Me,A.ShadowRenderPass=Vt,A.Skin=Lt,A.Skybox=ht,A.Sprite3D=Zn,A.SpriteBatchRenderer=ot,A.SpriteBillboardType=He,A.StandardMaterial=le,A.StandardMaterialAlphaMode=re,A.StandardMaterialDebugMode=ne,A.StandardMaterialNormalTexture=Rt,A.StandardMaterialOcclusionTexture=It,A.StandardMaterialTexture=xe,A.StandardPipeline=Ht,A.TextureTransform=ie,A.Transform3D=Ne,A.Vec3=x,A.glTFAsset=D,A.glTFBinaryLoader=pt,A.glTFLoader=gt,Object.defineProperty(A,"__esModule",{value:!0}),A}({},PIXI,PIXI,PIXI,PIXI,PIXI,PIXI,PIXI,PIXI.utils,PIXI,PIXI);
//# sourceMappingURL=pixi3d.min.js.map
